{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/02/06/Hexo%E6%92%AD%E5%AE%A2%E6%90%AD%E5%BB%BA/",
            "url": "http://example.com/2023/02/06/Hexo%E6%92%AD%E5%AE%A2%E6%90%AD%E5%BB%BA/",
            "title": "我的第一篇文章",
            "date_published": "2023-02-06T14:03:24.000Z",
            "content_html": "<h1 id=\"hexo博客搭建教程\"><a class=\"markdownIt-Anchor\" href=\"#hexo博客搭建教程\">#</a> Hexo 博客搭建教程</h1>\n<h2 id=\"第一步-安装软件\"><a class=\"markdownIt-Anchor\" href=\"#第一步-安装软件\">#</a> 第一步：安装软件</h2>\n<ol>\n<li>安装 git (省略)</li>\n<li>安装 node (省略)</li>\n</ol>\n<h2 id=\"第二步-软件安装完准备环境\"><a class=\"markdownIt-Anchor\" href=\"#第二步-软件安装完准备环境\">#</a> 第二步：软件安装完准备环境</h2>\n<ol>\n<li>\n<p>node 环境变量</p>\n<ol>\n<li>在 node 安装目录下新建 node_global,node_cache 文件夹</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206165200415.png\" alt=\"image-20230206165200415\"></p>\n<ol start=\"2\">\n<li>新建系统环境变量</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206165259142.png\" alt=\"image-20230206165259142\"></p>\n<ol start=\"3\">\n<li>用户变量 path 添加</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206165346037.png\" alt=\"image-20230206165346037\"></p>\n</li>\n<li>\n<p>更改缓存文件和模块默认存放位置</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm config set prefix \"node_global文件的路径\"</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>npm config set cache \"node_cache文件的路径\"</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>例如: npm config set prefix \"D:\\softlist\\nodejs\\node_global\"</pre></td></tr></table></figure></li>\n<li>\n<p>node 修改为淘宝镜像源</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>全局安装cnpm工具</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>npm install -g cnpm</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>//设置淘宝镜像</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>npm config set registry https://registry.npm.taobao.org</pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"第三步-cnpm安装hexo\"><a class=\"markdownIt-Anchor\" href=\"#第三步-cnpm安装hexo\">#</a> 第三步: cnpm 安装 hexo</h2>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>cnpm install -g hexo-cli</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206184704789.png\" alt=\"image-20230206184704789\"></p>\n<p>​\t\t安装完后可以用 <code>hexo -v</code>  查看安装情况</p>\n<h2 id=\"第四步创建博客目录\"><a class=\"markdownIt-Anchor\" href=\"#第四步创建博客目录\">#</a> 第四步：创建博客目录</h2>\n<ol>\n<li>\n<p>新建一个 blog 目录，并进入到该目录下</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>mkdir MyBlog</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>cd MyBlog</pre></td></tr></table></figure></li>\n<li>\n<p>初始化一个博客</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>//在刚刚创建的目录下执行该命令</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hexo init</pre></td></tr></table></figure></li>\n<li>\n<p>启动博客预览</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hexo s</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>//s=server</pre></td></tr></table></figure></li>\n<li>\n<p>复制启动后的地址到浏览器打开</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206205253052.png\" alt=\"image-20230206205253052\"></p>\n</li>\n<li>\n<p>新建一篇文章</p>\n<figure class=\"highlight nginx\"><figcaption data-lang=\"nginx\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hexo n \"我的第一篇文章\"</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>//n的意思是new</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206194149327.png\" alt=\"image-20230206194149327\"><br>\n 进入到文章所在的位置，\\source_posts, 编辑文章内容</p>\n</li>\n<li>\n<p>清理缓存并重新生成</p>\n<pre><code>hexo c\n//c = clean\n</code></pre>\n<pre><code>hexo g\n//g = generate\n</code></pre>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206205102586.png\" alt=\"image-20230206205102586\"></p>\n</li>\n<li>\n<p>启动重新生成的网站</p>\n<pre><code>hexo s\n//s = server\n</code></pre>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206205253052.png\" alt=\"image-20230206205253052\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206210528181.png\" alt=\"image-20230206210528181\"></p>\n</li>\n</ol>\n<h2 id=\"第五步部署博客\"><a class=\"markdownIt-Anchor\" href=\"#第五步部署博客\">#</a> 第五步：部署博客</h2>\n<ol>\n<li>\n<p>我们不能一直在本地看对吧，所以我们可以免费部署到 github 上</p>\n</li>\n<li>\n<p>进入 github 官网，新建仓库，仓库名字必须符合规则，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1naXRodWIrZ2l0aHViLTIwNHU3MDd4bnNzY3lmbS5pbw==\"> 你的 github 昵称 + github.io</span>, 然后点击 create 创建</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206212201619.png\" alt=\"image-20230206212201619\"></p>\n</li>\n<li>\n<p>上传文件到 github 仓库</p>\n<p>用管理员权限打开 git bash 窗口</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>//进入到你的博客目录下</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> 博客目录下</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>//进入到生成博客网站的目录</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token builtin class-name\">cd</span> public</pre></td></tr></table></figure><p>执行下列操作</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>//初始化一个仓库</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">git</span> init</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>//添加当前目录下的所有文件</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>//提交到本地分支</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"first commit\"</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>//把已存在的分子master改名为main,因为现在github仓库默认的主分支名字就是main</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">git</span> branch <span class=\"token parameter variable\">-M</span> main</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>//连接远程仓库并设置别名originblog</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">git</span> remote <span class=\"token function\">add</span> originblog https://github.com/cao-jvm/cao-jvm.github.io.git</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>//将本地内容推送到远程仓库</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token function\">git</span> push <span class=\"token parameter variable\">-u</span> origin main</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206215346152.png\" alt=\"image-20230206215346152\"></p>\n</li>\n<li>\n<p>上传完毕后访问网站</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>https://cao-jvm.github.io/</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/picgo/image-20230206215407210.png\" alt=\"image-20230206215407210\"></p>\n</li>\n<li>\n<p>当然了，这个只是最基本的搭建一个博客网站，主题是默认的，当然也是可以选择更加花里胡哨的主题，下篇文章再说</p>\n</li>\n</ol>\n",
            "tags": [
                "Hexo"
            ]
        },
        {
            "id": "http://example.com/2023/02/03/Linux/",
            "url": "http://example.com/2023/02/03/Linux/",
            "title": "Linux操作系统期末复习",
            "date_published": "2023-02-03T00:14:40.000Z",
            "content_html": "<h1 id=\"linux-操作系统期末复习\"><a class=\"markdownIt-Anchor\" href=\"#linux-操作系统期末复习\">#</a> Linux 操作系统期末复习</h1>\n<h2 id=\"单元一-安装与配置linux操作系统\"><a class=\"markdownIt-Anchor\" href=\"#单元一-安装与配置linux操作系统\">#</a> 单元一 \t安装与配置 Linux 操作系统</h2>\n<h3 id=\"考点\"><a class=\"markdownIt-Anchor\" href=\"#考点\">#</a> 考点</h3>\n<h4 id=\"1-linux创始人linus-torvalds-芬兰人\"><a class=\"markdownIt-Anchor\" href=\"#1-linux创始人linus-torvalds-芬兰人\">#</a> 1.  Linux 创始人：Linus Torvalds (芬兰人)</h4>\n<h4 id=\"2-linux-操作系统的优点\"><a class=\"markdownIt-Anchor\" href=\"#2-linux-操作系统的优点\">#</a> 2.  Linux 操作系统的优点</h4>\n<ul>\n<li>开源免费</li>\n<li>系统迭代更新</li>\n<li>系统性能稳定</li>\n<li>安全性能稳定</li>\n<li>多任务，多用户</li>\n<li>耗资源少</li>\n<li>内核小</li>\n<li>应用领域广泛</li>\n<li>入门及使用容易</li>\n</ul>\n<h4 id=\"3-linux发展有几大支柱\"><a class=\"markdownIt-Anchor\" href=\"#3-linux发展有几大支柱\">#</a> 3.  Linux 发展有几大支柱？</h4>\n<ol>\n<li>开源社区： Linux 是一个开源项目，其社区是其发展的核心。社区成员包括开发人员、用户、企业和组织，他们一起贡献代码和改进 Linux 的功能和性能。</li>\n<li>商业支持： Linux 获得了广泛的商业支持，包括大型 IT 公司和软件公司，他们在研发、销售和提供服务方面为 Linux 做出了巨大贡献。</li>\n<li>应用领域： Linux 在不断扩大的应用领域中取得了巨大成功，包括服务器、移动设备、物联网、智能家居、汽车电子、医疗信息系统等。</li>\n</ol>\n<h4 id=\"4-linux版本\"><a class=\"markdownIt-Anchor\" href=\"#4-linux版本\">#</a> 4.  Linux 版本</h4>\n<ol>\n<li>\n<p>linux 版本分为内核版和发行版，格式通常为主版本号，次版本号，修正号。其中次版本号：偶数表示稳定版本，奇数表示开发版本。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>例：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">3.10</span>.0-327.el7.x86_64</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>第一组数字：3 代表主版本号</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>第二组数字：10表示次版本号，稳定版本</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>第三组数字：0-327，修订版本，表示修改的次数</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>el7是REHL7系列的</pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"5-分区\"><a class=\"markdownIt-Anchor\" href=\"#5-分区\">#</a> 5. 分区</h4>\n<ol>\n<li>Linux 至少要安装两个分区：根分区和交换分区（root 和 swap）</li>\n</ol>\n<h4 id=\"6-课后习题\"><a class=\"markdownIt-Anchor\" href=\"#6-课后习题\">#</a> 6. 课后习题</h4>\n<p>一、单选题<br>\n 1. 下列_____________是自由软件。<br>\n（15.0 分）</p>\n<p>A、Windows10<br>\nB、UNIX<br>\nC、Linux<br>\nD、Windows Server 2016<br>\n 正确答案: C<br>\n2.Linux 的内核版本 2.3.20 是_______________版本。（15.0 分）</p>\n<p>A、不稳定<br>\n B、稳定的<br>\n C、第三次修订<br>\n D、第二次修订<br>\n正确答案: A<br>\n 二、填空题<br>\n 3.Linux 诞生于 1991 年 10 月 5 日，由_____________开发的。（14.0 分）</p>\n<p>正确答案: Linus Torvalds; 林纳斯。托瓦兹<br>\n 4.Linux 是一个_________任务、___________用户的操作系统。（14.0 分）</p>\n<p>正确答案：多     多</p>\n<p>5.Linux 的版本分为____________和___________________。（14.0 分）</p>\n<p>正确答案：内核版  发行版<br>\n 6. 安装 Linux 最少需要两个分区，分别是___________和______________。（14.0 分）</p>\n<p>正确答案：根分区   交换分区<br>\n 7.Linux 默认的系统管理员账号是______________。<br>\n（14.0 分）</p>\n<p>正确答案: root</p>\n<h2 id=\"单元二管理文件系统\"><a class=\"markdownIt-Anchor\" href=\"#单元二管理文件系统\">#</a> 单元二\t管理文件系统</h2>\n<h3 id=\"考点-2\"><a class=\"markdownIt-Anchor\" href=\"#考点-2\">#</a> 考点：</h3>\n<h4 id=\"1-文件系统类型至少掌握5个\"><a class=\"markdownIt-Anchor\" href=\"#1-文件系统类型至少掌握5个\">#</a> 1. 文件系统类型（至少掌握 5 个）</h4>\n<ul>\n<li>ext2：早期 Linux 中常用的文件系统</li>\n<li>ext3：ext2 的升级版，带日志功能</li>\n<li>FAT：Windows XP 操作系统采用的文件系统</li>\n<li>NTFS：Windows NT/XP 操作系统采用的文件系统</li>\n<li>ISO9660：大部分光盘所采用的文件系统</li>\n</ul>\n<h4 id=\"2-linux文件系统目录结构\"><a class=\"markdownIt-Anchor\" href=\"#2-linux文件系统目录结构\">#</a> 2. Linux 文件系统目录结构</h4>\n<ul>\n<li>Linux 系统中文件和目录名称都是严格区分大小写的，并且名称中不得包含斜杠（/）</li>\n</ul>\n<h4 id=\"3-linux默认目录功能\"><a class=\"markdownIt-Anchor\" href=\"#3-linux默认目录功能\">#</a> 3. Linux 默认目录功能</h4>\n<p>| /     | 根目录，文件的最顶端，整个文件系统的                         |<br>\n| ----- | ------------------------------------------------------------ |<br>\n| /bin  | 存放系统所需要的重要命令，ls，cp，mkdir 等，usr/bin 也存放了一些系统命令，这些命令对应的文件都是可执行的，普通用户可以使用大部分的命令 |<br>\n| /etc  | 一般存放系统的配置文件，作为一些软件启动时默认配置文件读取的目录，如 etc/fstab 存放系统分区信息 |<br>\n| /root | Linux 超级权限用户的 root 目录                                  |<br>\n| /var  | 这个目录的内容经常变动，/var/log 用于存放系统日志，/var/lib 存放系统库文件等 |</p>\n<h4 id=\"4-文件权限与归属\"><a class=\"markdownIt-Anchor\" href=\"#4-文件权限与归属\">#</a> 4. 文件权限与归属</h4>\n<p>| —    | 普通文件     |<br>\n| ---- | ------------ |<br>\n| d    | 目录文件     |<br>\n| l    | 链接文件     |<br>\n| b    | 块设备文件   |<br>\n| c    | 字符设备文件 |<br>\n| p    | 管道文件     |</p>\n<p>文件的读写执行权限简写为 rwx，可分别用数字 4，2，1 表示</p>\n<p>​</p>\n<p>​\t\t\t\t文件权限的字符与数字表示</p>\n<table>\n<thead>\n<tr>\n<th>权限分配</th>\n<th>文件所有者</th>\n<th>文件所属组</th>\n<th>其他用户</th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>权限项</td>\n<td>读</td>\n<td>写</td>\n<td>执行</td>\n<td>读</td>\n<td>写</td>\n<td>执行</td>\n<td>读</td>\n<td>写</td>\n<td>执行</td>\n</tr>\n<tr>\n<td>字符表示</td>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n<td>r</td>\n<td>w</td>\n<td>x</td>\n</tr>\n<tr>\n<td>数字表示</td>\n<td>4</td>\n<td>2</td>\n<td>1</td>\n<td>4</td>\n<td>2</td>\n<td>1</td>\n<td>4</td>\n<td>2</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"5-什么是硬链接什么是软链接\"><a class=\"markdownIt-Anchor\" href=\"#5-什么是硬链接什么是软链接\">#</a> 5. 什么是硬链接，什么是软链接</h4>\n<ul>\n<li>\n<p>硬链接 (hark link)：是指在文件系统中为一个已存在文件创建的另一个文件名，它们都指向同一个文件的 inode（文件索引节点），所以硬链接文件和原文件共享同一个 inode。如果原文件被删除，硬链接文件仍能正常使用，因为它们都指向同一个 inode。</p>\n</li>\n<li>\n<p>软链接 (也称为符号链接 symbolic link): 是指在文件系统中为一个已存在文件创建的另一个文件名，不同于硬链接，软链接文件并不指向 inode，而是指向原文件的路径。如果原文件被删除或更名，软链接文件就会失效。</p>\n</li>\n<li>\n<p>可以使用 ln 命令来创建硬链接和软链接。使用 - s 参数来创建软链接，不带任何参数就是创建硬链接。 例： ln -s /path/to/original/file/path/to/symbolic/link ln /path/to/original/file/path/to/hard/link</p>\n</li>\n<li>\n<p>（不用背，了解即可）</p>\n<p>inode (Index Node) 是 Linux 文件系统中的一种结构，用于存储文件的元数据，例如文件的权限、所有者、大小、时间戳等。</p>\n<p>每个文件在文件系统中都有一个唯一的 inode，inode 号在文件系统中是唯一的。文件名只是一个指向 inode 的指针，而文件的实际数据则存储在 inode 所指向的数据块中。这就是为什么在 Linux 系统中可以使用硬链接，因为硬链接只是另一个指向同一个 inode 的文件名。</p>\n<p>当文件被删除时，文件系统会回收文件的 inode 号，但是文件的数据块不会立即被回收，直到文件系统中没有指向它的 inode 号。</p>\n<p>一般来说，我们不需要关心 inode 号，因为 Linux 文件系统会自动维护它。但是，在一些特殊情况下，例如文件系统碎片整理或恢复文件时，需要了解 inode 号的概念。</p>\n</li>\n</ul>\n<h4 id=\"6-操作命令\"><a class=\"markdownIt-Anchor\" href=\"#6-操作命令\">#</a> 6. 操作命令</h4>\n<ul>\n<li>\n<p>wc 命令：wc 命令英语统计指定文本的行数，字数，字节数，格式为 “wc [参数][文本]”</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>例：ls<span class=\"token operator\">|</span><span class=\"token function\">wc</span> <span class=\"token parameter variable\">-l</span> 显示当前目录下所有文件数量</pre></td></tr></table></figure><p>​</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-l</td>\n<td>只显示行数</td>\n</tr>\n<tr>\n<td>-w</td>\n<td>只显示单词数</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>只显示字节数</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>mkdir 命令：用于创建空白的目录，格式为 “mkdir [选项][目录]”，可以结合 - p 参数来递归创建出具有嵌套关系的文件目录</p>\n</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>例：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> <span class=\"token function\">mkdir</span> <span class=\"token parameter variable\">-p</span> a/b/c/d/e</pre></td></tr></table></figure><p>​</p>\n<ul>\n<li>\n<p>rmdir 命令：用于删除空白目录，格式为 “[rmdir][选项][目录]“，也可以结合 - p 参数来递归删除具有嵌套叠层关系的文件目录，删除指定目录后，若该目录的上层目录变成空目录，则将其一并删除。</p>\n<p>例：<br>\nrmdir -p a/b/c/d/e</p>\n</li>\n<li>\n<p>cp 命令 **(必考)**：用于复制文件或目录，格式为 &quot;cp [选项][源文件][目标文件]&quot;，复制分三种情况：</p>\n<ul>\n<li>如果目标文件是目录，则会把源文件复制到该目录中；</li>\n<li>如果目标是存在的普通文件，则会询问，是否要覆盖他；</li>\n<li>如果目标文件不存在，则执行正常的复制操作</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-r</td>\n<td>递归连续复制（用于目录）</td>\n</tr>\n<tr>\n<td>-f，–force</td>\n<td>强行复制文件或目录，不论目标文件或目录是否已存在</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>保留原始文件的属性</td>\n</tr>\n<tr>\n<td>-d</td>\n<td>若对象为 “链接文件”，则保留该 “链接文件” 的属性</td>\n</tr>\n<tr>\n<td>-i</td>\n<td>若目标文件存在则询问是否覆盖</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>tar 命令：用来建立，还原备份文件。格式为 “tar [选项][文件]”（常用的备份工具，tar，cpio，dump）</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-c</td>\n<td>创建新的文档</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>显示详细的 tar 处理的文件信息</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>要操作的文件名，切记，这个参数是最后一个参数</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>解压</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>查看内容</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>有 gzip 属性的</td>\n</tr>\n<tr>\n<td>-j</td>\n<td>有 bz2 属性的</td>\n</tr>\n<tr>\n<td>-r</td>\n<td>表示增加文件，把要增加的文件追加在压缩文件的末尾</td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意：c 和 x 不可同时出现，常用的一般是 czvf，xzvf</strong></p>\n</li>\n<li>\n<p>find 命令：用于按照指定的条件来查找<strong>文件</strong>，格式为 “find [查找路径][寻找条件操作]&quot;</p>\n<p>注意要和 grep 区分开来，两个命令的主要区别就是 grep 是查找文本中的<strong>字符串</strong>，find 是查找<strong>文件或文件夹</strong>，并可以对查找到的文件进行操作。</p>\n</li>\n<li>\n<p>chmod 命令：主要用于修改文件或者目录的权限，例如 chmod o+w test.txt，赋予其他人写入权限，语法格式：chmod [选项][模式，模式][文件]</p>\n</li>\n</ul>\n<h4 id=\"7-单元二课后习题\"><a class=\"markdownIt-Anchor\" href=\"#7-单元二课后习题\">#</a> 7. 单元二课后习题</h4>\n<p>一、单选题<br>\n 1. 如果忘记了 ls 命令的用法，可以采用（    ）命令获得帮助。（5.0 分）</p>\n<p>A、?ls<br>\nB、help ls<br>\nC、man ls<br>\nD、get ls<br>\n 正确答案: C<br>\n2. 存放 Linux 基本命令的目录是什么？（          ）（5.0 分）</p>\n<p>A、/bin<br>\nB、/tmp<br>\nC、/lib<br>\nD、/root<br>\n 正确答案: A<br>\n3. 如果当前目录是 /home/sea/china，那么 “china” 的父目录是哪个目录？（  ）<br>\n（5.0 分）</p>\n<p>A、/home/sea<br>\nB、/home<br>\nC、/<br>\nD、/seas<br>\n 正确答案: A<br>\n4. 用 ls -al 命令列出下面的文件列表，哪个文件是符号链接文件？（   ）（5.0 分）</p>\n<p>A、-rw-------    2    hel-s    users    56    Sep    09    11:05    hello<br>\nB、-rw-------    2    hel-s    users    56    Sep    09    11:05    goodbye<br>\nC、drwx------    2    hel-s    users    56    Sep    09    11:05    zhang<br>\nD、lrw-------    2    hel-s    users    56    Sep    09    11:05    cheng<br>\n 正确答案: D<br>\n5. 要查看当前所在的目录，应使用的命令是（    ）。（5.0 分）</p>\n<p>A、pwd<br>\nB、ls<br>\nC、ls  -l<br>\nD、ls  -A<br>\n 正确答案: A<br>\n6. 用长格式形式使用 ls 命令列出当前目录下的文件和目录，命令是（   ）。（5.0 分）</p>\n<p>A、ls  -a<br>\nB、ls  -A<br>\nC、cd<br>\nD、ls  -l<br>\n 正确答案: D<br>\n7. 在当前目录下，创建测试目录 test 的命令是（    ）。（5.0 分）</p>\n<p>A、touch test<br>\nB、rmdir test<br>\nC、mkdir test<br>\nD、rm test<br>\n 正确答案: C<br>\n8. 在当前目录创建一个新的空文件 newfile，命令是（    ）。（5.0 分）</p>\n<p>A、mkdir  newfile<br>\nB、touch newfile<br>\nC、rmdir newfile<br>\nD、rm newfile<br>\n 正确答案: B<br>\n9. 利用 cp 命令复制系统文件 /etc/profile 到当前目录下，命令是（    ）。（5.0 分）</p>\n<p>A、#cp  /etc/profile/<br>\nB、#cp  /etc/profile  ./<br>\nC、#cp  /    /etc/profile<br>\nD、#cp  ./    /etc/profile<br>\n 正确答案: B<br>\n10. 复制文件 profile 到一个新文件 profile.bak 作为备份，命令是（    ）。（5.0 分）</p>\n<p>A、cp  profile   profile.bak<br>\nB、cp   profile.bak  profile</p>\n<p>C、mv  profile  profile.bak<br>\nD、mv  profile.bak  profile<br>\n 正确答案: A<br>\n11. 删除 test 子目录下的所有文件，命令是（    ）。（5.0 分）</p>\n<p>A、#rm  -rf  test<br>\nB、#rmdir  test<br>\nC、#rmdir  -r  test<br>\nD、#mkdir  -r  test<br>\n 正确答案: A<br>\n12. 用 less 命令分屏查看文件 profile 的内容，命令是（    ）。（5.0 分）</p>\n<p>A、#less  profile<br>\nB、#profile less<br>\nC、#more  profile<br>\nD、#profile  more<br>\n 正确答案: A<br>\n 二、填空题<br>\n 13. 在 Linux 系统中命令________大小写。在命令行中，可以使用_________键来自动补齐命令。<br>\n（4.0 分）</p>\n<p>正确答案：区分     tab<br>\n14. 如果在一个命令行上输入和执行多条命令，可以使用_______来分隔命令。<br>\n（4.0 分）</p>\n<p>正确答案: ;; 分号<br>\n 15. 要使程序以后台方式执行，只需要在执行命令后跟上一个_______符号。（4.0 分）</p>\n<p>正确答案: &amp;<br>\n16.________代表当前目录，也可以用./ 来表示。_______代表上一层目录，也可以用…/ 来表示。（4.0 分）</p>\n<p>正确答案: .    …<br>\n17. 若文件名前多一个 “.”，则代表该文件为_________，可以使用_________命令查看隐藏文件。（4.0 分）</p>\n<p>正确答案：隐藏文件    ls -a<br>\n 三、简答题<br>\n 18. 在使用 rm 命令删除文件或目录时，可使用哪个参数来避免二次确认呢？（10.0 分）<br>\n-f<br>\n19. 某链接文件的权限用数字表示法为 755，那么相应的字符法表示是什么呢？（10.0 分）</p>\n<p>如果一个链接文件的权限用数字表示法为 755，那么相应的字符表示法为 lrwxr-xr-x.</p>\n<p>其中:<br>\nl: 代表链接文件<br>\n rwx：文件所有者有读、写、执行权限<br>\n r-x：文件所属组有读、执行权限<br>\n r-x：其他用户有读、执行权限</p>\n<p>‘rwx’ 代表文件所有者有读 ®、写 (w)、执行 (x) 权限。<br>\n‘r-x’ 代表文件所属组有读 ®、执行 (x) 权限，没有写 (w) 权限。<br>\n‘r-x’ 代表其他用户有读 ®、执行 (x) 权限，没有写 (w) 权限。</p>\n<h2 id=\"单元三-shell与文本处理\"><a class=\"markdownIt-Anchor\" href=\"#单元三-shell与文本处理\">#</a> 单元三 \tShell 与文本处理</h2>\n<h3 id=\"考点-3\"><a class=\"markdownIt-Anchor\" href=\"#考点-3\">#</a> 考点</h3>\n<h4 id=\"1-vim-编辑器模式的切换方法\"><a class=\"markdownIt-Anchor\" href=\"#1-vim-编辑器模式的切换方法\">#</a> 1. vim 编辑器模式的切换方法</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230127152414755.png?token=AQ6CS6NUR6DSDHBOF6BP5BDD2N6GE\" alt=\"image-20230127152414755\"></p>\n<h4 id=\"2-输入输出重定向\"><a class=\"markdownIt-Anchor\" href=\"#2-输入输出重定向\">#</a> 2. 输入输出重定向</h4>\n<p>输入重定向是指把文件导入命令中， 而输出重定向是指把原本要输出到屏幕的数据信息，写入指定文件中</p>\n<h4 id=\"3-管道命令符\"><a class=\"markdownIt-Anchor\" href=\"#3-管道命令符\">#</a> 3. 管道命令符</h4>\n<p>作用如下：“把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入”</p>\n<p>Shell 提供管道命令 “|”，格式为  命令 1 | 命令 2 | 命令 3 | …| 命令 n</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>例：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>用翻页的形式查看/etc目录中的文件列表及属性信息</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ls-l /etc <span class=\"token operator\">|</span><span class=\"token function\">more</span></pre></td></tr></table></figure><h2 id=\"单元四-管理linux服务器的用户-组群及特殊权限\"><a class=\"markdownIt-Anchor\" href=\"#单元四-管理linux服务器的用户-组群及特殊权限\">#</a> 单元四 管理 Linux 服务器的用户、组群及特殊权限</h2>\n<h3 id=\"考点-4\"><a class=\"markdownIt-Anchor\" href=\"#考点-4\">#</a> 考点</h3>\n<h4 id=\"1-linux用户\"><a class=\"markdownIt-Anchor\" href=\"#1-linux用户\">#</a> 1. Linux 用户</h4>\n<ul>\n<li>管理员 UID 为 0：系统的管理员用户</li>\n<li>系统用户 UID 为 1—999：Linux 系统为了避免因某个服务程序出现漏洞而被黑客提权至整台服务器，默认服务程序会有独立的系统用户负责运行，进而有效控制被破坏的范围。</li>\n<li>普通用户 UID 从 1000 开始：是由管理员创建的用于日常工作的用户.</li>\n</ul>\n<h4 id=\"2-用户账户文件\"><a class=\"markdownIt-Anchor\" href=\"#2-用户账户文件\">#</a> 2. 用户账户文件</h4>\n<ol>\n<li>\n<p>/etc/passwd 文件：是 Linux 和 Unix 系统中用于存储用户账号信息的文件。该文件包含了每个用户的用户名、密码、用户 ID (UID)、组 ID (GID)、家目录以及登录时使用的 shell 等信息。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>/etc/passwd文件中每一行都是一个用户的信息，字段之间用冒号<span class=\"token punctuation\">(</span>:<span class=\"token punctuation\">)</span>分隔，每个字段的意义如下：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>用户名：登录系统时使用的用户名。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>密码：存储的是加密后的密码，对于本地用户来说，这一栏会是一个<span class=\"token string\">\"x\"</span>或者<span class=\"token string\">\"*\"</span>。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>用户 ID <span class=\"token punctuation\">(</span><span class=\"token environment constant\">UID</span><span class=\"token punctuation\">)</span>：用户的唯一标识。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>组 ID <span class=\"token punctuation\">(</span>GID<span class=\"token punctuation\">)</span>：用户所属的组的唯一标识。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>用户描述：一些关于用户的附加信息。</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>家目录：用户登录后所进入的目录。</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>登录时使用的 shell：用户登录后所使用的 shell。</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>如：root:x:0:0:root:/root:/bin/bash</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>注：由于/etc/passwd存储了密码的加密信息，所以它不能被普通用户读取。</pre></td></tr></table></figure></li>\n<li>\n<p>/etc/shadow 文件：是 Linux 和 Unix 系统中用于存储用户密码的加密信息的文件。这个文件与 /etc/passwd 文件配合使用，用于保证密码的安全性。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>/etc/shadow文件中每一行都是一个用户的信息，字段之间用冒号<span class=\"token punctuation\">(</span>:<span class=\"token punctuation\">)</span>分隔，每个字段的意义如下：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>用户名：与/etc/passwd文件中的用户名相同</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>密码：存储的是加密后的密码。一般是以<span class=\"token variable\">$id</span><span class=\"token variable\">$salt</span><span class=\"token variable\">$hashed</span>的形式存储，id表示使用的加密算法，salt是随机生成的盐值，hashed是哈希值</pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"3用户账户的创建和管理\"><a class=\"markdownIt-Anchor\" href=\"#3用户账户的创建和管理\">#</a> 3. 用户账户的创建和管理</h4>\n<ol>\n<li>su 命令:su (substitute user) 命令是一个 Linux 和 Unix 系统中的命令，用于切换当前登录用户的身份。它可以让当前用户切换到其他用户，并在切换后拥有该用户的权限和环境变量。切换用户的命令是 su 或者 su-</li>\n</ol>\n<p>常用格式是：su [options] [username]</p>\n<p>其中，username 是要切换的用户名。如果不指定用户名，默认切换到 root 用户。</p>\n<p>注意: su- 连用户和 Shell 环境一起切换；su 只切换用户而不切换环境</p>\n<ol start=\"2\">\n<li>\n<p>useradd 命令：是 Linux 和 Unix 系统中用于创建新用户帐号的命令。它用于在系统中添加新用户，并且可以通过命令行参数来设置新用户的属性和权限。</p>\n<p>常用格式是：useradd [options] username, 其中，username 是要创建的用户名。</p>\n<pre><code>常用选项有:\n\n-c comment : 设置新用户的说明信息\n-d home_dir : 设置新用户的主目录\n-e expire_date : 设置新用户的账号过期日期\n-g initial_group : 设置新用户的默认组\n-m : 创建新用户的主目录并复制默认文件\n-s shell : 设置新用户的默认 Shell\n-u uid : 设置新用户的 UID\n-M : 不创建新用户的主目录\n-U : 创建新用户并同时创建一个新的组\n\n例如：useradd -c &quot;John Doe&quot; -d /home/johndoe -m johndoe\n这个命令就是创建名为johndoe的用户,说明信息为John Doe，主目录为/home/johndoe，并且创建目录\n\nuseradd -u 500 -g 100 johndoe\n这个命令就是创建名为johndoe的用户,并设置uid为500,gid为100\n注意：创建用户后需要给用户设置密码,未设置的用户不能登陆系统,可以使用passwd命令或者usermod命令来设置.\n</code></pre>\n</li>\n<li>\n<p>passwd 命令:passwd 命令是 Linux 和 Unix 系统中用于修改用户密码的命令。它用于修改当前用户或其他用户的密码。</p>\n<p>常用格式是：passwd [options] [username]</p>\n<p>其中，username 是要修改密码的用户名。如果不指定用户名，则默认修改当前用户的密码。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>常用选项有:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-a</span> <span class=\"token builtin class-name\">:</span> 指定密码加密算法</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-d</span> <span class=\"token builtin class-name\">:</span> 删除用户密码</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token builtin class-name\">:</span> 强制用户立即更改密码</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-f</span> <span class=\"token builtin class-name\">:</span> 设置密码最小天数</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-l</span> <span class=\"token builtin class-name\">:</span> 锁定用户帐号</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-u</span> <span class=\"token builtin class-name\">:</span> 解锁用户帐号</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-n</span> <span class=\"token builtin class-name\">:</span> 设置密码最小天数</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token parameter variable\">-x</span> <span class=\"token builtin class-name\">:</span> 设置密码最大天数</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token parameter variable\">-S</span> <span class=\"token builtin class-name\">:</span> 显示用户密码状态信息</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>例如：passwd</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>这个命令就是修改当前用户的密码，系统会要求输入新密码两次</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token function\">passwd</span> johndoe</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>这个命令就是修改名为johndoe的用户的密码，需要有相应权限</pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>注意：在修改密码时会要求输入新密码和确认新密码。修改密码时，系统会检查新密码是否符合安全规则<span class=\"token punctuation\">(</span>如，密码长度、字符类型等<span class=\"token punctuation\">)</span>。</pre></td></tr></table></figure></li>\n<li>\n<p>usermod 命令：是 linux 和 Unix 系统中用于修改用户信息的命令。用于修改已存在的用户的账户信息。</p>\n<p>常用格式是：usermod [options] username</p>\n<p>其中，username 是要修改的用户名。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>常用选项有:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-c</span> <span class=\"token builtin class-name\">:</span> 修改用户的注释性描述</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-d</span> <span class=\"token builtin class-name\">:</span> 修改用户的家目录</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-e</span> <span class=\"token builtin class-name\">:</span> 修改用户的有效期</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token parameter variable\">-g</span> <span class=\"token builtin class-name\">:</span> 修改用户的主组</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token parameter variable\">-G</span> <span class=\"token builtin class-name\">:</span> 修改用户的附加组</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token parameter variable\">-l</span> <span class=\"token builtin class-name\">:</span> 修改用户的登录名</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token parameter variable\">-L</span> <span class=\"token builtin class-name\">:</span> 锁定用户账户</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token parameter variable\">-u</span> <span class=\"token builtin class-name\">:</span> 修改用户的用户ID</pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token parameter variable\">-U</span> <span class=\"token builtin class-name\">:</span> 解锁用户账户</pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token parameter variable\">-s</span> <span class=\"token builtin class-name\">:</span> 修改用户的登录shell</pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token parameter variable\">-a</span> <span class=\"token builtin class-name\">:</span> 显示所有选项</pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>例如：</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token function\">usermod</span> <span class=\"token parameter variable\">-c</span> <span class=\"token string\">\"John Doe\"</span> johndoe</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>这个命令就是将名为johndoe的用户的注释描述修改为<span class=\"token string\">\"John Doe\"</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token function\">usermod</span> <span class=\"token parameter variable\">-d</span> /home/johndoe <span class=\"token parameter variable\">-m</span> johndoe</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>这个命令就是将名为johndoe的用户的家目录修改为/home/johndoe并将其中的文件移动到新目录</pre></td></tr></table></figure></li>\n<li>\n<p>userdel 命令：是 Linux 和 Unix 系统中用于删除用户的命令。它可以删除用户的账户和相关信息。</p>\n<p>常用格式是：userdel [options] username</p>\n<p>其中，username 是要删除的用户名。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>常用选项有:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token parameter variable\">-r</span> <span class=\"token builtin class-name\">:</span> 删除用户的家目录和相关文件</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token parameter variable\">-f</span> <span class=\"token builtin class-name\">:</span> 强制删除，不提示是否删除</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token parameter variable\">-Z</span> <span class=\"token builtin class-name\">:</span> 删除SELinux用户</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>例如：</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">userdel</span> <span class=\"token parameter variable\">-r</span> johndoe</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>这个命令就是将名为johndoe的用户删除,并删除其家目录和相关文件</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">userdel</span> <span class=\"token parameter variable\">-f</span> johndoe</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>这个命令就是将名为johndoe的用户删除,不会提示是否删除</pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"4-课后题必考\"><a class=\"markdownIt-Anchor\" href=\"#4-课后题必考\">#</a> 4. 课后题 (必考)</h4>\n<p>linux 中什么命令可以用来检测用户 lisa 的信息？</p>\n<p>A. finger lisa\tB. grep lisa \t/etc/password\tC. find lisa /etc/password\tD. who lisa</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>这些些命令可以用来检测用户信息，如：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>finger 命令</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>getent 命令</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">grep</span> 命令</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">cat</span> /etc/passwd 命令</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>这些命令都可以用来查看用户的相关信息。</pre></td></tr></table></figure><h2 id=\"单元五-管理磁盘\"><a class=\"markdownIt-Anchor\" href=\"#单元五-管理磁盘\">#</a> 单元五 管理磁盘</h2>\n<h3 id=\"考点-5\"><a class=\"markdownIt-Anchor\" href=\"#考点-5\">#</a> 考点</h3>\n<h4 id=\"1-硬盘分区相关知识\"><a class=\"markdownIt-Anchor\" href=\"#1-硬盘分区相关知识\">#</a> 1. 硬盘分区相关知识</h4>\n<p>扩展分区：并不是一个真正的分区，而更像是一个占用了 16 字节分区表空间的指针 ---- 一个指向另一个分区的指针</p>\n<p>用户一般会选择使用 3 个主分区 (Primary’) 加一个扩展分区 (Extended) 的方法，然后再扩展分区中创建出数个逻辑分区 (Logical), 从而来满足多分区 (大于 4 个) 的需求.</p>\n<p>磁盘容量 = 主分区 + 扩展分区</p>\n<p>(知识拓展，了解即可)</p>\n<p>为什么主分区不能超过 4 个</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Linux 中主分区不能超过四个的原因是因为主分区是由 BIOS 引导程序读取的，而 BIOS 只能识别 MBR（主引导记录）中最多 <span class=\"token number\">4</span> 个主分区的信息。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>MBR 是在硬盘的第一个扇区中存储的，它包含了硬盘的分区信息和系统引导程序。MBR 的大小是固定的，只有 <span class=\"token number\">446</span> 字节，其中 <span class=\"token number\">63</span> 字节用来存储系统引导程序，剩下的用来存储硬盘分区信息。每个分区信息占用 <span class=\"token number\">16</span> 字节。因此，最多只能有 <span class=\"token number\">4</span> 个主分区（4*16<span class=\"token operator\">=</span><span class=\"token number\">64</span>）。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>而对于超过4个的分区，可以使用逻辑分区来解决。逻辑分区是在一个主分区内部划分出来的，并不占用主分区的限制。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>总结来说，主分区最多只能有 <span class=\"token number\">4</span> 个的原因是由于 MBR 的大小限制造成的。</pre></td></tr></table></figure><h4 id=\"2-mount挂载分区\"><a class=\"markdownIt-Anchor\" href=\"#2-mount挂载分区\">#</a> 2. mount 挂载分区</h4>\n<p>是 Linux 系统中用来挂载分区或者文件系统的命令。挂载的作用是将一个文件系统连接到某一目录上，这样用户就可以通过访问这个目录来访问文件系统上的文件。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">mount</span> 命令的一般语法是：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">mount</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> device directory</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>该device参数指定要挂载的设备或分区。这可以是设备文件（例如 /dev/sda1）、UUID 或 LABEL。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>directory参数是文件系统上要挂载设备的位置。这通常称为挂载点。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>该options参数指定您在安装设备时要使用的任何其他选项。一些常见的选项包括rw（读写）、ro（只读）和auto（在启动时自动挂载）。</pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>比如你在/dev/sda1上有一个分区，你想挂载到/mnt目录下，可以使用如下命令：</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token function\">mount</span> /dev/sda1 /mnt</pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>这会将位于 /dev/sda1 的分区挂载到 /mnt 目录，使其可以读写。</pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>请注意，您需要是超级用户或具有适当的权限才能挂载或卸载分区。</pre></td></tr></table></figure><h4 id=\"3-umount卸载命令\"><a class=\"markdownIt-Anchor\" href=\"#3-umount卸载命令\">#</a> 3. umount 卸载命令</h4>\n<p>umount 命令在 Linux 中用于卸载当前挂载的文件系统或分区。此命令与 mount 命令相反，允许您从文件系统中安全地删除设备或分区。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">umount</span> 命令的一般语法是：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">umount</span> <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> directory</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>directory参数是当前安装设备的文件系统位置。这通常称为挂载点。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>该options参数指定卸载设备时要使用的任何其他选项。\t</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>例如，如果 /dev/sda1 上有一个分区当前挂载在 /mnt 目录下，则可以使用以下命令：</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">umount</span> /mnt</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>这将从 /mnt 目录中卸载位于 /dev/sda1 上的分区，使其不再可读写。</pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>请注意，您需要是超级用户或具有适当的权限才能卸载分区。此外，您无法卸载当前正在使用的分区。</pre></td></tr></table></figure><h2 id=\"单元六-软件包的安装与管理\"><a class=\"markdownIt-Anchor\" href=\"#单元六-软件包的安装与管理\">#</a> 单元六 软件包的安装与管理</h2>\n<h3 id=\"考点-6\"><a class=\"markdownIt-Anchor\" href=\"#考点-6\">#</a> 考点:</h3>\n<h4 id=\"1-rpm包管理系统\"><a class=\"markdownIt-Anchor\" href=\"#1-rpm包管理系统\">#</a> 1. RPM 包管理系统</h4>\n<p>RPM（Red Hat Package Manager）是 Red Hat、Fedora 和 CentOS 等 Linux 发行版使用的包管理系统。它用于在 Linux 系统上安装、更新和删除软件包。</p>\n<p>RPM 包的文件扩展名为 .rpm，包含在 Linux 系统上安装软件包所需的所有文件和信息。该包包括文件本身，以及关于包的元数据，例如它的名称、版本和依赖项。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>用于处理 RPM 包的主要命令是rpm命令。该命令的一些最常见用途rpm包括：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">rpm</span> <span class=\"token parameter variable\">-i</span> package.rpm: 该命令用于在 Linux 系统上安装 RPM 包。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">rpm</span> <span class=\"token parameter variable\">-U</span> package.rpm：此命令用于将现有包升级到更新版本。<span class=\"token punctuation\">(</span>U可用upgrade代替,效果一样<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token function\">rpm</span> -V<span class=\"token operator\">|</span>Va package.rpm:该rpm命令将根据包的原始元数据验证已安装包的完整性。这对于确保包在安装后未被篡改或修改很有用。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token function\">rpm</span> <span class=\"token parameter variable\">-e</span> package：此命令用于从 Linux 系统中删除已安装的软件包。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token function\">rpm</span> <span class=\"token parameter variable\">-q</span> package: 该命令用于查询软件包的信息，如名称、版本、安装位置等。</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token function\">rpm</span> <span class=\"token parameter variable\">-ql</span> package: 该命令用于列出已安装包中包含的文件。</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>RPM 包还包括依赖项，这意味着当你安装一个包时，它也会安装主包所依赖的所有包。当您卸载一个包时，它也会卸载依赖于该包的所有包。</pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>请注意，RPM 主要用于基于 Red Hat 的发行版，基于 Debian 的发行版如 Ubuntu、Debian、Mint 使用dpkg包管理器，其命令是dpkg.</pre></td></tr></table></figure><h2 id=\"单元七-linux系统监视与进程管理\"><a class=\"markdownIt-Anchor\" href=\"#单元七-linux系统监视与进程管理\">#</a> 单元七 Linux 系统监视与进程管理</h2>\n<h3 id=\"考点-7\"><a class=\"markdownIt-Anchor\" href=\"#考点-7\">#</a> 考点</h3>\n<h4 id=\"1-at调度必考\"><a class=\"markdownIt-Anchor\" href=\"#1-at调度必考\">#</a> 1. at 调度 (必考)</h4>\n<p>该 <code>at</code>  命令用于安排命令或脚本在将来的特定时间运行。该命令可用于安排一次性任务或重复性任务。</p>\n<p>该 <code>at</code>  命令的基本语法如下：</p>\n<p>at [time]</p>\n<p><code>time</code>  任务应该执行的具体时间在哪里，以几种格式之一指定。例如，您可以指定特定时间，例如 <code>3:00 PM</code> ，也可以使用相对时间，例如 <code>now + 1 hour</code> 。</p>\n<p>输入 <code>at</code>  命令后，系统将提示您输入要在指定时间运行的命令或脚本。输入命令后，按 <code>CTRL+D</code>  提交任务。</p>\n<p>您还可以使用该 <code>atq</code>  命令查看所有计划任务的列表，并使用该 <code>atrm</code>  命令删除计划任务。</p>\n<p>注意:at 调度和 batch 调度指定的命令只能运行一次 (batch 和 at 的区别就是不指定运行时间，进程将在比较空闲时候运行)</p>\n<h4 id=\"2-corn\"><a class=\"markdownIt-Anchor\" href=\"#2-corn\">#</a> 2. corn</h4>\n<p>Cron 是一种 Linux 实用程序，可让您安排任务（也称为 cron 作业）在特定时间或间隔自动执行。cron 守护程序或 crond 在后台运行并检查 crontab（cron 表）是否有任何计划任务。如果安排了任务，cron 守护进程将在指定的时间执行它。</p>\n<p>crontab 文件是指定 cron 作业时间表的配置文件，用于设置和管理 cron 任务。crontab 文件中的每一行代表一个 cron 作业，其计划以下列格式指定：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>* * * * * <span class=\"token builtin class-name\">command</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>- - - - -</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span> ----- Day of week <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> - <span class=\"token number\">7</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>Sunday <span class=\"token operator\">=</span> both <span class=\"token number\">0</span> and <span class=\"token number\">7</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token operator\">|</span> <span class=\"token operator\">|</span> ------- Month <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> - <span class=\"token number\">12</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token operator\">|</span> <span class=\"token operator\">|</span> --------- Day of month <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> - <span class=\"token number\">31</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token operator\">|</span> ----------- Hour <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> - <span class=\"token number\">23</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>------------- Minute <span class=\"token punctuation\">(</span><span class=\"token number\">0</span> - <span class=\"token number\">59</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>例如，crontab 文件中的一行如下所示：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">0</span> <span class=\"token number\">0</span> * * * /usr/local/bin/my-script.sh</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>该行将在每天午夜运行脚本 /usr/local/bin/my-script.sh。</pre></td></tr></table></figure><pre><code>每天早上6点执行脚本：\n0 6 * * * /path/to/script.sh\n\n每周一和周三的下午4点执行脚本：\n0 16 * * 1,3 /path/to/script.sh\n\n每隔2小时执行一次脚本：\n0 */2 * * * /path/to/script.sh\n\n每月1日和15日的上午9点执行脚本：\n0 9 1,15 * * /path/to/script.sh\n\n每年12月31日晚上11点执行脚本：\n0 23 31 12 * /path/to/script.sh\n\n</code></pre>\n<h4 id=\"3-监视进程\"><a class=\"markdownIt-Anchor\" href=\"#3-监视进程\">#</a> 3. 监视进程</h4>\n<ol>\n<li>\n<p>ps 命令 (是静态的)</p>\n<p>命令（“进程状态” 的 <code>ps</code>  缩写）是 Linux 中的命令行实用程序，可显示有关系统上运行的进程的信息。默认情况下， <code>ps</code>  将显示有关在当前终端会话中运行的进程的信息。</p>\n<p>该 <code>ps</code>  命令的基本语法是：</p>\n<p>ps [options]</p>\n<pre><code>最常用的选项ps包括：\n\n-ef|-e: 显示系统上运行的所有进程\n-aux: 显示所有用户的所有进程\n-u: 显示运行进程的用户信息\n-p: 按PID显示特定进程的信息\n例如，该命令ps -ef将显示系统上运行的所有进程，包括进程ID、用户、进程名称和命令。\n\n您还可以使用ps -aux来显示系统上运行的所有进程，包括进程 ID、用户、CPU 使用率、内存使用率和其他详细信息。\n\n也可以使用grep命令过滤命令的输出，ps只显示你感兴趣的进程。\n\n请注意，ps默认情况下显示当前终端会话中运行的进程，如果你想查看系统上运行的所有进程，你需要使用 -ef 或 -aux 等选项。\n</code></pre>\n</li>\n<li>\n<p>top 命令 (是动态的，可刷新)</p>\n<p><code>top</code>  命令是 Linux 中的系统监视实用程序，可<strong>实时显示</strong>有关系统上运行的进程的信息。它提供系统上运行的进程的<strong>动态、实时视图</strong>，包括进程 ID、用户、CPU 使用率、内存使用率和其他详细信息。</p>\n<p>当您运行该 <code>top</code>  命令时，它将显示系统上当前正在运行的进程列表，使用最多 CPU 的进程位于列表顶部。该列表是实时更新的，因此您可以看到系统的资源使用情况如何随时间变化。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>可与该top命令一起使用的一些常见选项和参数包括：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>-d：指定更新之间的延迟，以秒为单位。例如，top <span class=\"token parameter variable\">-d</span> <span class=\"token number\">5</span>将每 <span class=\"token number\">5</span> 秒更新一次显示。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>-p：显示特定进程 ID 的进程。例如，top <span class=\"token parameter variable\">-p</span> <span class=\"token number\">1234</span>将显示 ID 为 <span class=\"token number\">1234</span> 的进程的信息。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>-u：显示特定用户的进程。例如，top <span class=\"token parameter variable\">-u</span> root将显示以 root 用户身份运行的所有进程的信息。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>-n：迭代次数。例如，top <span class=\"token parameter variable\">-n</span> <span class=\"token number\">2</span>只会运行命令 <span class=\"token number\">2</span> 次然后退出。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>-o：指定排序字段。例如，top <span class=\"token parameter variable\">-o</span> %MEM将根据内存使用情况对进程进行排序</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>-h：显示帮助信息</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>q: 退出top命令</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>k: 通过PID杀死一个进程</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>r：Renice一个过程的PID</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>s：更改刷新间隔</pre></td></tr></table></figure></li>\n<li>\n<p>kill 命令 (必考)</p>\n<p>该 <code>kill</code>  命令用于向进程发送信号以终止进程或更改其行为。</p>\n<p>默认情况下， <code>kill</code>  发送 <code>SIGTERM</code>  信号，要求进程正常终止。该命令的基本语法是：</p>\n<p>kill [signal] PID</p>\n<p>哪里 <code>signal</code>  是你要发送的信号， <code>PID</code>  是你要终止的进程的进程 ID。如果未指定信号， <code>SIGTERM</code>  则使用。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>可以发送的一些常见信号kill包括：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>SIGTERM<span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>默认<span class=\"token punctuation\">)</span> - 要求进程正常终止</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>SIGKILL<span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span> - 强制进程立即终止</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>SIGSTOP<span class=\"token punctuation\">(</span><span class=\"token number\">19</span><span class=\"token punctuation\">)</span> - 停止进程</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>SIGCONT<span class=\"token punctuation\">(</span><span class=\"token number\">18</span><span class=\"token punctuation\">)</span> - 继续停止的进程</pre></td></tr></table></figure><p>kill 命令终止的是后台命令，终止一个前台命令可以用 Ctrl+c 组合键</p>\n</li>\n</ol>\n<h4 id=\"4-启动切换进程或作业\"><a class=\"markdownIt-Anchor\" href=\"#4-启动切换进程或作业\">#</a> 4. 启动，切换进程或作业</h4>\n<ol>\n<li>\n<p>手动启动：指用户输入 Shell 命令直接启动进程，又分<strong>前台启动</strong>和<strong>后台启动</strong>.</p>\n<p>在输入的 Shell 命令末尾加上 &amp; 符号，再按 Enter 键，可启动一个<strong>后台作业</strong></p>\n</li>\n<li>\n<p>作业的前后台切换</p>\n<ol>\n<li>\n<p>bg 命令</p>\n<p>bg 命令用于将当前正在后台运行的任务转移到前台运行。例如，如果您正在运行一个长时间运行的命令，并且希望在继续使用终端时将其转移到前台，则可以使用 bg 命令。</p>\n<p>格式：bg [jobspec]。如果没有指定 jobspec (表示一个特定的进程)，则默认转移最后一个后台任务。</p>\n<p>作业号一般是通过 jobs 命令查到的后台正在执行的命令的序号 (不是 pid)</p>\n<p>例:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">#jobs</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>+ Running /root/bin/rsync.sh <span class=\"token operator\">&amp;</span></pre></td></tr></table></figure></li>\n<li>\n<p>fg 命令</p>\n<p>fg 命令是 Linux 中用来将后台进程放到前台执行的命令。</p>\n<p>该命令的格式为：</p>\n<p>fg [jobspec]</p>\n<p>其中，jobspec 可以是一个进程的 PID 或者是一个运行在后台的进程的 job ID。如果不指定 jobspec，则 fg 命令会将最后一个运行在后台的进程放到前台。当进程在前台运行时，用户可以对该进程进行控制，例如使用 Ctrl+C 终止进程等。</p>\n<p>例如：fg %1 将 job ID 为 1 的进程放到前台执行 (%1 为是通过 jobs 命令查到的后台正在执行的命令的序号)</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"单元九-shell编程-shell-script\"><a class=\"markdownIt-Anchor\" href=\"#单元九-shell编程-shell-script\">#</a> 单元九 Shell 编程 - Shell script</h2>\n<h3 id=\"考点-8\"><a class=\"markdownIt-Anchor\" href=\"#考点-8\">#</a> 考点</h3>\n<h4 id=\"1-shell脚本的建立和执行\"><a class=\"markdownIt-Anchor\" href=\"#1-shell脚本的建立和执行\">#</a> 1. Shell 脚本的建立和执行</h4>\n<p>Shell 脚本是在 Linux 或 UNIX 系统中使用的一种脚本语言，可以用来自动化系统任务或重复性任务。它包括一组命令，这些命令在一起执行一个任务。(不需要编译，可直接执行，解释执行)</p>\n<p>建立 Shell 脚本的方法：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span>.使用文本编辑器（如 vi、nano、gedit 等）创建一个新文件，并在其中输入所需的命令。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2</span>.在第一行添加一个特殊的行，即 “<span class=\"token comment\">#! /bin/bash” 或 “#! /bin/sh”，这样系统就知道该文件是一个 Shell 脚本。</span></pre></td></tr></table></figure><p>注意:#! /bin/bash 是一种特殊的注释，# 是注释，！告诉 Shell 执行感叹号之后的命令。它告诉系统该脚本应该用 /bin/bash 来执行。这样做是为了确保脚本使用的是 bash shell，而不是其他的 shell。</p>\n<h4 id=\"2-文件测试符\"><a class=\"markdownIt-Anchor\" href=\"#2-文件测试符\">#</a> 2. 文件测试符</h4>\n<p>文件测试符是 Linux 中常用的条件判断命令，它可以对文件进行各种属性的测试，并根据测试结果返回 true 或 false。</p>\n<ul>\n<li><strong>-e: 文件是否存在</strong> (可能会考)</li>\n<li><strong>-f: 是否为普通文件</strong> (可能会考)</li>\n<li>-d: 是否为目录</li>\n<li>-r: 是否可读</li>\n<li>-w: 是否可写</li>\n<li>-x: 是否可执行</li>\n<li>-s: 文件大小是否大于 0</li>\n</ul>\n<p>使用方法是在文件前面加上测试符，如:</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-e</span> <span class=\"token string\">\"/etc/passwd\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"passwd file exist\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"passwd file not exist\"</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">fi</span></pre></td></tr></table></figure><h4 id=\"3-shell编程题\"><a class=\"markdownIt-Anchor\" href=\"#3-shell编程题\">#</a> 3. Shell 编程题</h4>\n<ol>\n<li>\n<p>编写 Shell 脚本，计算 1-100 的和.</p>\n<p>以下代码是 chatgpt 给出，未验证正确性</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token shebang important\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># This script is used to calculate the sum of numbers from 1 to 100</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># Initialize a variable named \"sum\" to store the result</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># Use a for loop to iterate through the numbers from 1 to 100</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">100</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\"># Add the current number to the \"sum\" variable</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token assign-left variable\">sum</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$((</span>sum <span class=\"token operator\">+</span> i<span class=\"token variable\">))</span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token comment\"># Print the final result</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"The sum of numbers from 1 to 100 is: <span class=\"token variable\">$sum</span>\"</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>第1行：<span class=\"token comment\">#!/bin/bash 是脚本的第一行，表示这是一个 shell 脚本，并且使用 /bin/bash 来执行。</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>第3行：初始化变量 <span class=\"token function\">sum</span> 为 <span class=\"token number\">0</span>。</pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>第5行：使用 <span class=\"token keyword\">for</span> 循环迭代变量 i，从 <span class=\"token number\">1</span> 到 <span class=\"token number\">100</span>。</pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>第7行：使用 <span class=\"token variable\"><span class=\"token variable\">$((</span>sum <span class=\"token operator\">+</span> i<span class=\"token variable\">))</span></span> 来计算当前的 i 值并将其加到 <span class=\"token function\">sum</span> 变量中。</pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>第9行：使用 <span class=\"token builtin class-name\">echo</span> 打印出最终结果。</pre></td></tr></table></figure><p>我自己编写的，已验证正确性</p>\n<pre><code>#! /bin/bash\n\n# this is a add one to fifty\n\nfor((i=1;i&lt;=100;i++));\ndo\nSUM=$(expr $SUM + $i)\ndone\n\necho $SUM\n</code></pre>\n</li>\n<li>\n<p>用 shell 编程实现在屏幕上输出九九乘法表。</p>\n<p>以下代码是 chatgpt 给出，未验证正确性</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token shebang important\">#!/bin/bash</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">9</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">j</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> $i<span class=\"token variable\">)</span></span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$i</span>*<span class=\"token variable\">$j</span>=<span class=\"token variable\"><span class=\"token variable\">$((</span>i<span class=\"token operator\">*</span>j<span class=\"token variable\">))</span></span> \"</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>说明：</pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">#!/bin/bash：指定这是一个 bash 脚本</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">i</span> <span class=\"token keyword\">in</span> <span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">..</span><span class=\"token number\">9</span><span class=\"token punctuation\">&#125;</span>：循环变量 i 从 <span class=\"token number\">1</span> 到 <span class=\"token number\">9</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">j</span> <span class=\"token keyword\">in</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">seq</span> <span class=\"token number\">1</span> $i<span class=\"token variable\">)</span></span>：循环变量 j 从 <span class=\"token number\">1</span> 到 i</pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$i</span>*<span class=\"token variable\">$j</span>=<span class=\"token variable\"><span class=\"token variable\">$((</span>i<span class=\"token operator\">*</span>j<span class=\"token variable\">))</span></span> \"</span>：输出乘法结果，-n 选项表示不换行</pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\"</span>：输出换行</pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>如果要运行这个脚本，需要给它加上可执行权限，并在命令行中执行它，例如：</pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token function\">chmod</span> +x script.sh</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>./script.sh</pre></td></tr></table></figure><p>我自己的代码，已验证正确性</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token shebang important\">#! /bin/bash</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span><span class=\"token number\">9</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">for</span><span class=\"token variable\"><span class=\"token punctuation\">((</span>j<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>j<span class=\"token operator\">&lt;=</span>i<span class=\"token punctuation\">;</span>j<span class=\"token operator\">++</span><span class=\"token punctuation\">))</span></span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token keyword\">do</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token builtin class-name\">echo</span> <span class=\"token parameter variable\">-n</span> <span class=\"token string\">\"<span class=\"token variable\">$&#123;j&#125;</span>*<span class=\"token variable\">$&#123;i&#125;</span>=<span class=\"token variable\"><span class=\"token variable\">$((</span>i<span class=\"token operator\">*</span>j<span class=\"token variable\">))</span></span> \"</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">done</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token builtin class-name\">echo</span><span class=\"token string\">\"\"</span> <span class=\"token comment\">#输出一行后换行</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token keyword\">done</span></pre></td></tr></table></figure></li>\n</ol>\n",
            "tags": [
                "复习"
            ]
        },
        {
            "id": "http://example.com/2023/02/02/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3%E4%B8%8E%E5%86%99%E4%BD%9C%E5%A4%8D%E4%B9%A0/",
            "url": "http://example.com/2023/02/02/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3%E4%B8%8E%E5%86%99%E4%BD%9C%E5%A4%8D%E4%B9%A0/",
            "title": "软件写作期末复习",
            "date_published": "2023-02-02T00:14:40.000Z",
            "content_html": "<h1 id=\"第一章\"><a class=\"markdownIt-Anchor\" href=\"#第一章\">#</a> 第一章</h1>\n<h3 id=\"什么是软件文档\"><a class=\"markdownIt-Anchor\" href=\"#什么是软件文档\">#</a> 什么是软件文档</h3>\n<ol>\n<li>软件文档描述系统功能，刻画子系统间的相互关系，是为开发者提供的精确、完整的指导资料。软件文档是软件开发者之间的沟通渠道，是具体工作的安排表，是系统的开发标准。</li>\n</ol>\n<h3 id=\"软件文档的作用\"><a class=\"markdownIt-Anchor\" href=\"#软件文档的作用\">#</a> 软件文档的作用</h3>\n<ol>\n<li>\n<p>软件文档的本质作用是桥梁、是纽带，连接着软件开发方、管理人员，用户以及计算机，将其构成一个相互影响、相互作用的整体。</p>\n</li>\n<li>\n<p>网上的版本（仅供参考）</p>\n<ul>\n<li>项目管理的依据</li>\n<li>技术交流的语言</li>\n<li>保证项目质量</li>\n<li>培训与维护的资料</li>\n<li>软件维护支持</li>\n<li>记载软件历史的语言</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"软件文档的分类及作用\"><a class=\"markdownIt-Anchor\" href=\"#软件文档的分类及作用\">#</a> 软件文档的分类及作用</h3>\n<ul>\n<li>开发文档 —— 描述开发过程本身</li>\n<li>管理文档 —— 记录项目管理的信息</li>\n<li>用户文档 —— 记录用户所需的信息</li>\n</ul>\n<h1 id=\"第二章软件文档的写作规范\"><a class=\"markdownIt-Anchor\" href=\"#第二章软件文档的写作规范\">#</a> 第二章 —— 软件文档的写作规范</h1>\n<br/>\n<h3 id=\"一个软件项目从立项到结尾共有几个阶段\"><a class=\"markdownIt-Anchor\" href=\"#一个软件项目从立项到结尾共有几个阶段\">#</a> 一个软件项目从立项到结尾共有几个阶段：</h3>\n<ol>\n<li>立项，投标，需求分析，概要设计，详细设计，软件编码，软件测试，维护，验收</li>\n</ol>\n<br/>\n<h3 id=\"名词解析体系结构功能模块\"><a class=\"markdownIt-Anchor\" href=\"#名词解析体系结构功能模块\">#</a> 名词解析 —— 体系结构，功能模块</h3>\n<ul>\n<li>体系结构：是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构件、和连接构件。</li>\n<li>功能模块：</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第三章软件项目立项阶段文档写作案例分析\"><a class=\"markdownIt-Anchor\" href=\"#第三章软件项目立项阶段文档写作案例分析\">#</a> 第三章 —— 软件项目立项阶段文档写作案例分析</h1>\n<br/>\n<h3 id=\"名词解析市场风险技术风险\"><a class=\"markdownIt-Anchor\" href=\"#名词解析市场风险技术风险\">#</a> 名词解析 —— 市场风险，技术风险</h3>\n<ul>\n<li>市场风险：市场风险是因市场价格变动招致损失的风险</li>\n<li>技术风险：技术风险是指伴随着科学技术的发展、生产方式的改变而产生的威胁人们生产与生活的风险。</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第四章需求分析书案例分析\"><a class=\"markdownIt-Anchor\" href=\"#第四章需求分析书案例分析\">#</a> 第四章 —— 需求分析书案例分析</h1>\n<br/>\n<h3 id=\"需求分析书是干什么的\"><a class=\"markdownIt-Anchor\" href=\"#需求分析书是干什么的\">#</a> 需求分析书是干什么的</h3>\n<ul>\n<li>一般是对某个市场或者是客户群来讲的，类似于调研报告，重点是体现出产品要满足哪些功能，哪些是重点、热点。</li>\n</ul>\n<h3 id=\"需求分析书有哪些功能\"><a class=\"markdownIt-Anchor\" href=\"#需求分析书有哪些功能\">#</a> 需求分析书有哪些功能</h3>\n<br/>\n<h3 id=\"名词解析用例方法用例规约ipo图响应时间故障处理\"><a class=\"markdownIt-Anchor\" href=\"#名词解析用例方法用例规约ipo图响应时间故障处理\">#</a> 名词解析 —— 用例方法，用例规约，IPO 图，响应时间，故障处理</h3>\n<br/>\n<ul>\n<li>用例方法：用例方法主要是用来描述需求的业务流程</li>\n<li>用例规约：用例规约就是以用例方式组织的需求规约，是对用例图的解释说明</li>\n<li>IPO 图：IPO 图是对每个模块进行详细设计的工具，它是输入加工输出图的简称，它是由美国 IBM 公司发起并完善起来的一种工具。</li>\n<li>响应时间：指应用执行一个操作所需的时间，包括从发出请求开始到最后收到响应所需要的时间。</li>\n<li>故障处理：是指在故障发生之后，采取措施，使系统尽快恢复正常</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第五章需求分析书案例分析二\"><a class=\"markdownIt-Anchor\" href=\"#第五章需求分析书案例分析二\">#</a> 第五章 —— 需求分析书案例分析二</h1>\n<br/>\n<br/>\n<h3 id=\"什么是功能需求包括哪些\"><a class=\"markdownIt-Anchor\" href=\"#什么是功能需求包括哪些\">#</a> 什么是功能需求，包括哪些</h3>\n<p>规定开发人员必须在产品中实现的软件功能，用户利用这些功能来完成任务，满足业务需求。</p>\n<p>例如：登录功能，在线播放等用户需要实现的业务</p>\n<h3 id=\"非功能需求包括哪些\"><a class=\"markdownIt-Anchor\" href=\"#非功能需求包括哪些\">#</a> 非功能需求包括哪些</h3>\n<ul>\n<li>性能需求 —— 用户在软件响应速度、结果精度、运行时资源消耗量等方面的要求</li>\n<li>可靠性要求 —— 用户在软件失效的频率、严重程度、易恢复性，以及故障可预测性等方面的要求。</li>\n<li>易用性要求 —— 用户在界面的易用性、美观性，以及对面向用户的文档和培训资料等方面的要求。</li>\n<li>运行环境约束 —— 用户对软件系统运行环境的要求。</li>\n<li>外部接口需求 —— 用户对待开发软件系统与其他软件系统或硬件设备之间的接口的要求。</li>\n<li>安全性需求 —— 用户在身份认证、授权控制、私密性等方面的要求。</li>\n<li>可保障性要求 —— 用户在软件可配置性、可扩展性、可维护性、可移植性等方面的要求。</li>\n<li>输入输入需求</li>\n<li>数据管理能力需求</li>\n<li>故障处理需求 —— 一旦运行发生异常应当有信息提示，用户无法进行违规操作</li>\n</ul>\n<br/>\n<h3 id=\"什么是非功能需求\"><a class=\"markdownIt-Anchor\" href=\"#什么是非功能需求\">#</a> 什么是非功能需求（*）</h3>\n<p>是指 软件产品 为满足用户业务需求而必须具有且除功能需求以外的特性，包括安全性、可靠性、互操作性、健壮性等。</p>\n<br/>\n<h3 id=\"名词解析bscs\"><a class=\"markdownIt-Anchor\" href=\"#名词解析bscs\">#</a> 名词解析 ——B/S,C/S</h3>\n<ul>\n<li>\n<p>B/S—— 浏览器 / 服务端</p>\n<p>优点：不需要更新客户端</p>\n<p>缺点：交互性差，安全性低</p>\n</li>\n<li>\n<p>C/S—— 客户端 / 服务端</p>\n<p>优点：交互性好，对服务器压力小，安全</p>\n<p>缺点：服务器更新时需同步更新客户端</p>\n</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第六章需求分析书案例三\"><a class=\"markdownIt-Anchor\" href=\"#第六章需求分析书案例三\">#</a> 第六章 —— 需求分析书案例三</h1>\n<h3 id=\"建设原则有哪些\"><a class=\"markdownIt-Anchor\" href=\"#建设原则有哪些\">#</a> 建设原则有哪些</h3>\n<ul>\n<li>先进性</li>\n<li>实用性</li>\n<li>高可靠性</li>\n<li>开放性</li>\n<li>可维护性</li>\n<li>可移植性</li>\n<li>扩展性</li>\n</ul>\n<br/>\n<h3 id=\"名词解释可移植性可维护性扩展性\"><a class=\"markdownIt-Anchor\" href=\"#名词解释可移植性可维护性扩展性\">#</a> 名词解释 —— 可移植性，可维护性，扩展性</h3>\n<ul>\n<li>可移植性 —— 指与软件从某一环境转移到另一环境下的难易程度</li>\n<li>可维护性 —— 是衡量一个系统的可修复 (恢复) 性和可改进性的难易程度。 所谓可修复性是指在系统发生故障后能够排除 (或抑制) 故障予以修复，并返回到原来正常运行状态的可能性。</li>\n<li>扩展性 —— 可扩展性是软件拓展系统的能力。 简单地说，可扩展性就是关于如何处理更大规模的业务。</li>\n</ul>\n<br/>\n<h1 id=\"第七章概要设计书案例分析一\"><a class=\"markdownIt-Anchor\" href=\"#第七章概要设计书案例分析一\">#</a> 第七章 —— 概要设计书案例分析一</h1>\n<br/>\n<h3 id=\"概要设计是干什么的\"><a class=\"markdownIt-Anchor\" href=\"#概要设计是干什么的\">#</a> 概要设计是干什么的</h3>\n<ul>\n<li>概要设计是软件开发中非常重要的一个环节，它决定了软件的整体结构，决定了整个开发过程人员、时间的安排。</li>\n</ul>\n<h3 id=\"概要设计完成什么样的目标\"><a class=\"markdownIt-Anchor\" href=\"#概要设计完成什么样的目标\">#</a> 概要设计完成什么样的目标</h3>\n<ul>\n<li>在概要设计阶段，需要将软件系统需求转化为未来系统的设计，逐步开发强壮的系统构架，将系统进行合理的子系统，功能的分解</li>\n</ul>\n<br/>\n<h3 id=\"概要设计有个什么样的结果\"><a class=\"markdownIt-Anchor\" href=\"#概要设计有个什么样的结果\">#</a> 概要设计有个什么样的结果</h3>\n<br/>\n<br/>\n<h3 id=\"问答题-健壮性系统划分的基本原则是什么\"><a class=\"markdownIt-Anchor\" href=\"#问答题-健壮性系统划分的基本原则是什么\">#</a> 问答题 —— 健壮性，系统划分的基本原则是什么</h3>\n<ul>\n<li>健壮性 —— 健壮性具体指的是系统在不正常的输入或不正常的外部环境下仍能表现出正常的程度</li>\n<li>系统划分的基本原则是什么 —— 按照业务闭环进行系统拆分／组织架构划分，实现闭环／高内聚／低耦合，减少沟通成本</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第九章概要设计书案例分析三\"><a class=\"markdownIt-Anchor\" href=\"#第九章概要设计书案例分析三\">#</a> 第九章 —— 概要设计书案例分析三</h1>\n<br/>\n<h3 id=\"名词解释软件生命周期瀑布模型螺旋模型\"><a class=\"markdownIt-Anchor\" href=\"#名词解释软件生命周期瀑布模型螺旋模型\">#</a> 名词解释 —— 软件生命周期，瀑布模型，螺旋模型</h3>\n<ul>\n<li>软件生命周期 —— 软件生命周期 (Software Life Cycle,SLC) 是软件的产生直到报废或停止使用的生命周期。. 软件生命周期内有问题定义、 可行性分析 、总体描述、 系统设计 、编码、调试和测试、验收与运行、维护升级到废弃等阶段，也有将以上阶段的活动组合在内的迭代阶段，即迭代作为生命周期的阶段。</li>\n<li>瀑布模型 —— 瀑布模型是将软件生存周期的各项活动规定为按固定顺序而连接的若干阶段工作，形如瀑布流水，最终得到软件产品。</li>\n<li>螺旋模型 —— 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代特征以及瀑布模型的系统化与严格监控。</li>\n</ul>\n<br/>\n<h1 id=\"第十章详细设计书案例分析一\"><a class=\"markdownIt-Anchor\" href=\"#第十章详细设计书案例分析一\">#</a> 第十章 —— 详细设计书案例分析一</h1>\n<br/>\n<h3 id=\"名词解释算法n-s图pad图\"><a class=\"markdownIt-Anchor\" href=\"#名词解释算法n-s图pad图\">#</a> 名词解释 —— 算法，N-S 图，PAD 图</h3>\n<ul>\n<li>算法 —— 算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。</li>\n<li>N-S 图 ——N-S 图，也被称为盒图或 NS 图，是结构化编程中的一种可视化建模。</li>\n<li>PAD 图 ——PAD 是问题分析图（Problem Analysis Diagram）的英文缩写，是继 PFD 和 N-S 图之后，又一种描述详细设计的工具，是软件工程中的分析利器，它用二维数形结构的图表示程序的控制流，展现程序的逻辑结构（或者数据结构）, 将这种图转换为程序代码比较容易。</li>\n</ul>\n<h3 id=\"问答题\"><a class=\"markdownIt-Anchor\" href=\"#问答题\">#</a> 问答题</h3>\n<ul>\n<li>\n<p>详细设计是什么</p>\n<p>在概要设计完成整个系统的宏观设计后，再由详细设计对概要设计中提出的各个功能模块逐个进行详细分析，全面展开。</p>\n</li>\n<li>\n<p>详细设计要详细到什么程度，这样做的目的是什么？</p>\n<p>详细设计要包含所有模块的各方各面的内容，要细致到在编码之前没有任何不确定因素，包括函数名，类名等的命名，各个页面表示项目的属性，长度，特殊的限制，具体的算法也要在此阶段确定。</p>\n<p>目的是为了在编码阶段能将设计结果无歧义的直接转化为某种开发语言；另一方面也是为了以后维护人员在代码维护时能提供实用的帮助，不用在纷繁众多的代码中找不到切入点。</p>\n</li>\n<li>\n<p>通常可以借助哪些形式来描写算法？</p>\n<p>自然语言，流程图，伪代码等</p>\n</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第十一章详细设计书案例分析二\"><a class=\"markdownIt-Anchor\" href=\"#第十一章详细设计书案例分析二\">#</a> 第十一章 —— 详细设计书案例分析二</h1>\n<br/>\n<h3 id=\"详细设计过程工具选择题\"><a class=\"markdownIt-Anchor\" href=\"#详细设计过程工具选择题\">#</a> 详细设计过程工具（选择题）</h3>\n<ul>\n<li>流程图</li>\n<li>N-S 图</li>\n<li>PAD 图</li>\n<li>判定表</li>\n<li>判定树（决策树）</li>\n<li>过程设计语言（PDL）</li>\n</ul>\n<br/>\n<h3 id=\"名词解释判定表判定树\"><a class=\"markdownIt-Anchor\" href=\"#名词解释判定表判定树\">#</a> 名词解释 —— 判定表，判定树</h3>\n<ul>\n<li>判定表 —— 判定表 (Decision table) 是另一种表达逻辑判断的工具。 与结构化语言和判断树相比，判断表的优点是能把所有条件组合充分地表达出来；其缺点是判定表的建立过程较烦杂，且表达方式不如前两种简便。</li>\n<li>判定树 —— 判定树又称决策树，是一种用来表示逻辑判断问题的图形工具，适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。</li>\n</ul>\n<br/>\n<br/>\n<h1 id=\"第十二章软件项目结束阶段文档写作案例分析\"><a class=\"markdownIt-Anchor\" href=\"#第十二章软件项目结束阶段文档写作案例分析\">#</a> 第十二章 —— 软件项目结束阶段文档写作案例分析</h1>\n<br/>\n<h3 id=\"什么是功能测试\"><a class=\"markdownIt-Anchor\" href=\"#什么是功能测试\">#</a> 什么是功能测试</h3>\n<p>功能测试就是对产品的各功能进行验证，根据功能 测试用例 ，逐项测试，检查产品是否达到用户要求的功能。</p>\n<h3 id=\"名词解释黑盒测试白盒测试\"><a class=\"markdownIt-Anchor\" href=\"#名词解释黑盒测试白盒测试\">#</a> 名词解释 —— 黑盒测试，白盒测试</h3>\n<ul>\n<li>黑盒测试 —— 黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用，黑盒测试比较注重软件产品的 “功能性需求”。</li>\n<li>白盒测试 —— 白盒测试又称结构测试、透明盒测试、逻辑驱动测试或基于代码的测试。白盒测试是一种测试用例设计方法，盒子指的是被测试的软件，白盒指的是盒子是可视的，即清楚盒子内部的东西以及里面是如何运作的。</li>\n</ul>\n<br/>\n<h3 id=\"问答题-2\"><a class=\"markdownIt-Anchor\" href=\"#问答题-2\">#</a> 问答题</h3>\n<ol>\n<li>\n<p>为什么要进行测试？</p>\n<p>1、发现被测对象与用户需求之间的差异，即缺陷。</p>\n<p>2、通过测试活动发现并解决缺陷，增加人们对软件质量的信心。</p>\n<p>3、通过测试活动了解被测对象的质量状况，为决策提供数据依据。</p>\n<p>4、通过测试活动积累经验，预防缺陷出现，降低产品失败风险。</p>\n</li>\n<li>\n<p>常用的软件测试方法有哪些？</p>\n<ul>\n<li>等价类划分法</li>\n<li>场景法</li>\n<li>边界值分析法</li>\n<li>判定表</li>\n</ul>\n</li>\n</ol>\n",
            "tags": [
                "复习"
            ]
        },
        {
            "id": "http://example.com/2023/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/",
            "url": "http://example.com/2023/02/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/",
            "title": "操作系统原理期末复习",
            "date_published": "2023-02-01T00:14:40.000Z",
            "content_html": "<h1 id=\"操作系统原理期末复习\"><a class=\"markdownIt-Anchor\" href=\"#操作系统原理期末复习\">#</a> 操作系统原理期末复习</h1>\n<h2 id=\"考试内容\"><a class=\"markdownIt-Anchor\" href=\"#考试内容\">#</a> 考试内容:</h2>\n<h3 id=\"一-单选10个2分20分全是学习通上的题目\"><a class=\"markdownIt-Anchor\" href=\"#一-单选10个2分20分全是学习通上的题目\">#</a> 一 单选 (10 个 * 2 分 = 20 分)(全是学习通上的题目)</h3>\n<h3 id=\"二-判断题15个好像是1分一个也是学习通上的但是错误的地方需要改正\"><a class=\"markdownIt-Anchor\" href=\"#二-判断题15个好像是1分一个也是学习通上的但是错误的地方需要改正\">#</a> 二 判断题 (15 个，好像是 1 分一个)(也是学习通上的，但是错误的地方需要改正)</h3>\n<h3 id=\"三-填空题5个2分20分\"><a class=\"markdownIt-Anchor\" href=\"#三-填空题5个2分20分\">#</a> 三 填空题 (5 个 * 2 分 = 20 分)</h3>\n<h3 id=\"四-简答题5题-4分20分简答题答到要点即可\"><a class=\"markdownIt-Anchor\" href=\"#四-简答题5题-4分20分简答题答到要点即可\">#</a> 四 简答题 (5 题 *4 分 = 20 分)(简答题答到要点即可)</h3>\n<h3 id=\"五-综合题计算题平均周转时间等要有过程\"><a class=\"markdownIt-Anchor\" href=\"#五-综合题计算题平均周转时间等要有过程\">#</a> 五 综合题 (计算题，平均周转时间等，要有过程)</h3>\n<h2 id=\"第一章-引论\"><a class=\"markdownIt-Anchor\" href=\"#第一章-引论\">#</a> 第一章 引论</h2>\n<h3 id=\"考点\"><a class=\"markdownIt-Anchor\" href=\"#考点\">#</a> 考点:</h3>\n<h4 id=\"1-操作系统的概念必考操作系统是掌控管理计算机上所有事情的系统软件\"><a class=\"markdownIt-Anchor\" href=\"#1-操作系统的概念必考操作系统是掌控管理计算机上所有事情的系统软件\">#</a> 1. 操作系统的概念 (<mark>必考</mark>): 操作系统是掌控 (管理) 计算机上所有事情的系统软件</h4>\n<p>要完成以下 5 种功能 (定义):</p>\n<ol>\n<li>控制和管理季璇玑系统的所有硬件资源和软件资源</li>\n<li>合理的组织计算机的工作流程，保证计算机资源的公平竞争和使用</li>\n<li>方便用户使用计算机</li>\n<li>防止对计算机资源的非法侵占和使用</li>\n<li>保证操作系统自身的正常运转</li>\n</ol>\n<h4 id=\"2-操作系统在计算机系统中的地位\"><a class=\"markdownIt-Anchor\" href=\"#2-操作系统在计算机系统中的地位\">#</a> 2. 操作系统在计算机系统中的地位</h4>\n<p>操作系统是在硬件基础上的第一层软件，是其他软件和硬件之间的接口，是最重要的系统软件</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230130221002505.png?token=AQ6CS6N6WB76SPCUXEAP5XLD27IAI\" alt=\"image-20230130221002505\"></p>\n<h4 id=\"3-操作系统的主要功能\"><a class=\"markdownIt-Anchor\" href=\"#3-操作系统的主要功能\">#</a> 3. 操作系统的主要功能</h4>\n<ol>\n<li>\n<p>处理器管理</p>\n<p>对 CPU 资源进行分配，调度和管理线程和进程</p>\n</li>\n<li>\n<p>存储管理</p>\n<p>管理内存的使用，并确保各个任务的内存分配是合理的。</p>\n</li>\n<li>\n<p>设备管理</p>\n<p>管理和控制计算机中的各种设备，如磁盘、打印机、显示器等</p>\n</li>\n<li>\n<p>文件管理</p>\n<p>管理文件的存储和访问，包括创建、读取、写入和删除文件。</p>\n</li>\n<li>\n<p>用户接口</p>\n</li>\n<li>\n<p>网路与通信管理</p>\n</li>\n</ol>\n<h4 id=\"4-操作系统的基本特征\"><a class=\"markdownIt-Anchor\" href=\"#4-操作系统的基本特征\">#</a> 4. 操作系统的基本特征</h4>\n<ol>\n<li>\n<p>并发性</p>\n<p>并发性 (Concurrence) 是指两个或多个事件在同一时间间隔内发生。从而提高系统的效率。</p>\n</li>\n<li>\n<p>共享性</p>\n<p>共享性 共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p>\n</li>\n<li>\n<p>虚拟性</p>\n<p>虚拟性表现为把一个物理实体转变为若干个逻辑实体，物理实体是真实存在的，逻辑实体是虚拟的</p>\n</li>\n<li>\n<p>不确定性 (异步性)</p>\n<p>操作系统允许多个并发进程共享资源、相互合作，使得每个进程的运行过程受到其他进程的制约，不再 “一气呵成＂ ，这必然导致异步性特征的产生</p>\n</li>\n</ol>\n<h4 id=\"5-操作系统的逻辑结构和运行模型\"><a class=\"markdownIt-Anchor\" href=\"#5-操作系统的逻辑结构和运行模型\">#</a> 5. 操作系统的逻辑结构和运行模型</h4>\n<ol>\n<li>\n<p>用户态和内核态的划分 (为了安全)</p>\n<p>为了保护操作系统的重要性，通常的办法是采用内核态和用户态两种模式</p>\n<ul>\n<li>内核态：是指操作系统程序运行的状态，在该状态下可以执行操作系统的所有指令 (包括特权指令), 并能够使用系统的全部资源.</li>\n<li>用户态：是指用户运行的状态，在该状态下所能执行的指令和访问的资源都将受到限制</li>\n</ul>\n</li>\n<li>\n<p>内核态与用户态的转换</p>\n<p>中断和异常时 CPU 的状态从用户态转换到内核态 (核心态) 的唯一途径</p>\n<ol>\n<li>通过中断实现用户态到内核态的改变.(一般会提供一条专门的指令 &lt; 访管指令&gt; 中断)</li>\n<li>在内核态下由操作系统代替用户完成其请求 (用户指定的请求)</li>\n<li>操作系统完成指定操作后再通过修改程序状态字 (PSW) 由内核态切换为用户态</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-主要操作系统的类型\"><a class=\"markdownIt-Anchor\" href=\"#6-主要操作系统的类型\">#</a> 6. 主要操作系统的类型</h4>\n<ol>\n<li>\n<p>批处理操作系统</p>\n<p>这种操作系统通常用于大规模的数据处理，它不支持交互式操作，用户需要提交作业，然后系统自动执行。</p>\n</li>\n<li>\n<p>分时操作系统</p>\n<p>这种操作系统支持多个用户同时使用 (共享主机)，但是每个用户的处理时间是有限制的，系统会在用户之间动态分配处理时间。</p>\n<p>特征:</p>\n<ul>\n<li>独立性：用户彼此独立，互不干扰</li>\n<li>同时性：从宏观上看，多个终端用户在同时使用一台计算机</li>\n<li>交互性：可以人机交互</li>\n<li>及时性：用户的请求能够在足够短的时间内得到响应</li>\n</ul>\n</li>\n<li>\n<p>实时操作系统</p>\n<p>这种操作系统适用于对实时响应要求较高的系统，例如控制系统、生产线控制等，它需要在预定时间内完成任务。</p>\n</li>\n</ol>\n<h4 id=\"7-系统调用\"><a class=\"markdownIt-Anchor\" href=\"#7-系统调用\">#</a> 7. 系统调用</h4>\n<ol>\n<li>什么是系统调用 &lt;系统调用会产生中断&gt;(包含下面两方面的含义)\n<ul>\n<li>在操作系统内核中设置了一组用于实现各种系统功能的子程序 (内核函数)</li>\n<li>用户程序在用户态执行中需要系统内核提供服务时能够使用这组子程序</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"第二章-处理器管理\"><a class=\"markdownIt-Anchor\" href=\"#第二章-处理器管理\">#</a> 第二章 处理器管理</h2>\n<h3 id=\"考点-2\"><a class=\"markdownIt-Anchor\" href=\"#考点-2\">#</a> 考点</h3>\n<h4 id=\"1-进程\"><a class=\"markdownIt-Anchor\" href=\"#1-进程\">#</a> 1. 进程</h4>\n<ol>\n<li>\n<p>进程的定义</p>\n<p>进程是一个可并发执行的，具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和调度的基本单位 (注：现在保护已改为调度)</p>\n</li>\n<li>\n<p>进程控制块</p>\n<p>进程控制块 (PCB, Process Control Block) 是操作系统对每一个正在运行的进程进行描述和管理的数据结构。它通常包含进程的标识符、当前状态、寄存器信息、内存管理信息、调度信息等。操作系统通过读取和修改进程控制块中的信息来控制和调度进程的执行。(解释了解即可)</p>\n<p>下面的要掌握</p>\n<p><strong>进程实体 = 程序段 + 相关数据段 + PCB</strong></p>\n</li>\n</ol>\n<h4 id=\"2-进程的状态及转换\"><a class=\"markdownIt-Anchor\" href=\"#2-进程的状态及转换\">#</a> 2. 进程的状态及转换</h4>\n<ol>\n<li>\n<p><strong>进程的三态模型 (必考)</strong></p>\n<ol>\n<li>就绪态（Ready）：进程已经做好了执行准备，等待获得 CPU 资源 (就绪态的进程可以有多个，一般将它们组成一个进程就绪队列)。</li>\n<li>运行态（Running）：进程正在执行，占用 CPU 资源 (只能有一个进程处于运行状态)。</li>\n<li>阻塞态（Blocked）：进程由于某种原因暂时不能执行，例如等待 I/O 操作完成 (处于阻塞状态的进程可以有多个)。</li>\n</ol>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230131145956874.png?token=AQ6CS6O27YHN5UMFS225S2TD3C6KW\" alt=\"image-20230131145956874\"></p>\n</li>\n<li>\n<p>进程切换</p>\n<p>进程切换的实质是回收当前运行进程对 CPU 的控制权，并将 CPU 控制权转交给新调度的就绪进程</p>\n</li>\n<li>\n<p>进程上下文</p>\n<p>也就是现场信息 (比喻老师上次讲课讲到哪这次接着讲)</p>\n<p>分成三部分</p>\n<ul>\n<li>系统级上下文</li>\n<li>寄存器上下文</li>\n<li>用户级上下文</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-cpu的三级调度\"><a class=\"markdownIt-Anchor\" href=\"#4-cpu的三级调度\">#</a> 4. CPU 的三级调度</h4>\n<p>CPU 调度的层级可分为三级：高级调度，中级调度和低级调度，高级调度又称为作业调度，中级调度又称为交换调度，低级调度又称为进程调度</p>\n<ul>\n<li>\n<p>高级调度 (作业调度或宏观调度): 其功能是按照一定的调度算法把外存上处于后备作业队列中的作业调入内存，为他们分配所需的资源并创建进程，然后将新建的进程插入到系统的进程就绪队列中。在作业运行结束时，回收分配给作业的系统资源，撤销相应的数据结构 (如控制作业块 JCB)</p>\n<p>5 个主要功能</p>\n<ol>\n<li>选择作业</li>\n<li>分配资源</li>\n<li>创建进程</li>\n<li>作业控制</li>\n<li>回收资源</li>\n</ol>\n</li>\n<li>\n<p>中级调度 (交换调度): 其功能主要是在内存资源紧张的情况下，从内存中暂不运行的进程中选择一个或数个进程挂起，即由内存调至外存 (交换), 从而使外存上具备运行条件的就绪进程能够及时调入内存运行.</p>\n<p><strong>注意：换出至外存的进程可以是就绪进程也可以是阻塞进程，由于换至外存后处于挂起状态 (即静止就绪或静止阻塞状态), 因此不能参与低级调度 (进程调度)</strong></p>\n</li>\n<li>\n<p>低级调度 (进程调度或微观调度): 其主要功能是按照一定的调度算法将 CPU 分派给进程就绪队列中的某个进程.</p>\n</li>\n</ul>\n<p><strong>可以没有高级，中级调度，但是一定要有低级调度</strong></p>\n<h4 id=\"5-进程调度方式和时机\"><a class=\"markdownIt-Anchor\" href=\"#5-进程调度方式和时机\">#</a> 5. 进程调度方式和时机</h4>\n<ol>\n<li>\n<p>进程调度方式 (重点，可能会考)</p>\n<p>一般来说，进程的调度方式可分为<strong>非抢占式调度</strong>和<strong>抢占式调度</strong>两类</p>\n<ul>\n<li>\n<p>非抢占式调度</p>\n<p>指的是在执行的进程完成或请求资源之前，不会被系统强行剥夺 CPU 的使用权。这种方式通常在实时操作系统中使用。</p>\n</li>\n<li>\n<p>抢占式调度</p>\n<p>在没有发生等待事件的情况下也允许进程调度程序暂停当前运行进程的执行，并按照某种原则将当前运行进程占用的 CPU 分配给另一个更重要，更紧迫的进程使用。这种方式通常在非实时操作系统中使用。</p>\n<p>常用的抢占原则主要有以下两种:</p>\n<ol>\n<li>高优先级原则：如果有更高优先级的就绪进程到达时，则进程调度程序立即暂停当前运行进程的执行 (由运行态变为就绪态), 然后将 CPU 分配给这个更高优先级的就绪进程使用</li>\n<li>时间片原则：在分时系统中各就绪进程按照时间片轮流执行，当运行进程的时间片到时，则进程调度程序立即暂停当前运行进程的执行 (由运行态变为就绪态), 然后将 CPU 分配给下一个就绪进程</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"6-todo\"><a class=\"markdownIt-Anchor\" href=\"#6-todo\">#</a> 6. TODO</h4>\n<h2 id=\"第三章-进程同步与通信\"><a class=\"markdownIt-Anchor\" href=\"#第三章-进程同步与通信\">#</a> 第三章 进程同步与通信</h2>\n<h3 id=\"考点-3\"><a class=\"markdownIt-Anchor\" href=\"#考点-3\">#</a> 考点</h3>\n<h4 id=\"1-进程同步的基本概念\"><a class=\"markdownIt-Anchor\" href=\"#1-进程同步的基本概念\">#</a> 1. 进程同步的基本概念</h4>\n<ol>\n<li>\n<p>并发进程的关系</p>\n<p>对于相关的并发进程，则存在着以下两种相互制约的关系:</p>\n<ul>\n<li>\n<p>间接制约关系 (互斥): 是指并发进程之间的关系，它们不能同时执行，必须等待其他进程完成</p>\n<p>比如打印机，一段时间只能由一个进程使用的资源称为独占资源或互斥资源</p>\n</li>\n<li>\n<p>直接制约关系 (同步): 是指并发进程之间的一种关系，它们相互协调和同步，</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-进程的互斥与同步\"><a class=\"markdownIt-Anchor\" href=\"#2-进程的互斥与同步\">#</a> 2. 进程的互斥与同步</h2>\n<ol>\n<li>\n<p>进程同步：进程间的同步是指某些进程之间在逻辑上的相互制约的关系。这种相互合作等待对方消息的协调关系就称为同步</p>\n</li>\n<li>\n<p>进程互斥：进程互斥是指某一资源同一时间只允许一个进程对其进行访问，这种访问具有唯一性和排他性.</p>\n<p>进程互斥通常是进程之间争夺互斥资源而引起的，在这种情况下，任何时刻都不允许两个及两个以上的并发进程同时执行那段访问该互斥资源的程序代码.</p>\n<p>互斥的实现还会产生两个问题：饥饿和死锁</p>\n</li>\n</ol>\n<h4 id=\"3-临界资源与临界区\"><a class=\"markdownIt-Anchor\" href=\"#3-临界资源与临界区\">#</a> 3. 临界资源与临界区</h4>\n<ol>\n<li>\n<p>临界资源</p>\n<p>把一段时间内只允许一个进程使用的资源称为临界资源</p>\n</li>\n<li>\n<p>临界区</p>\n<p>把进程中访问 临界资源的代码段称为临界区</p>\n</li>\n<li>\n<p>无论采用何种同步机制，都应遵守以下 4 条准则:</p>\n<ol>\n<li>空闲让进：无进程处于临界区时意味着临界资源处于空闲状态，这是若有进程要求进入临界区应立即允许进入</li>\n<li>忙则等待：当一个进程在获取一个资源时，如果该资源正在被其他进程使用，那么这个进程应该等待其他进程释放该资源</li>\n<li>有限等待：若干进程要求进入访问同一临界资源的临界区时，应在有限时间内使一个进程进入临界区，即不应该出现各进程相互等待而都无法进入临界区的情况.</li>\n<li>让权等待：当进程不能进入其临界区时，应立即释放被其所占有的 CPU, 以免陷入 &quot;忙等&quot;(进程在占有 CPU 的同时又一直等待), 保证其他可执行的进程获得 CPU 运行</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-信号量机制\"><a class=\"markdownIt-Anchor\" href=\"#4-信号量机制\">#</a> 4. 信号量机制</h4>\n<ol>\n<li>\n<p>P , V 操作 (P 和 V 分别来源于荷兰文发信号和等待单词的第一个字母)</p>\n<p>信号量机制使用信号量及有关的 P,V 操作原语来解决进程的互斥与同步问题</p>\n<p><strong>操作 (必考)</strong></p>\n<ul>\n<li>\n<p><strong>P</strong></p>\n<p><strong>两步:</strong></p>\n<ol>\n<li><strong>信号量值减 1</strong></li>\n<li><strong>判断减 1 后的信号量值，如小于 0, 则阻塞调用该 P 操作的进程</strong></li>\n</ol>\n</li>\n<li>\n<p><strong>V</strong></p>\n<p><strong>两步:</strong></p>\n<ol>\n<li><strong>信号量值加 1</strong></li>\n<li><strong>判断信号量值，若信号量值小于等于 0, 则唤醒一个被该信号量阻塞的进程</strong></li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-产生死锁的原因和必要条件必考\"><a class=\"markdownIt-Anchor\" href=\"#5-产生死锁的原因和必要条件必考\">#</a> 5. 产生死锁的原因和必要条件 (必考)</h4>\n<ol>\n<li>\n<p>死锁的定义：所谓死锁，是指多个进程在并发执行过程中因争夺不可抢占资源而造成的一种僵局。当这种僵局状态出现时，其中一组进程或所有进程都处于永远等待 (阻塞) 状态。若无外力作用，这组进程或所有进程都无法继续向前推进，这种僵局就是死锁.</p>\n<p>老师上课自己概括的定义：2 个或 2 个以上的进程互相等待对方的资源并一直持续下去 (老师说的死锁定义，可能有误差，没听清楚上课)</p>\n</li>\n<li>\n<p>产生死锁的原因:</p>\n<ol>\n<li>系统资源不足：产生死锁的根本原因是可供多个进程共享的系统资源不足。当多个进程需求资源的总和大于系统能够提供的资源时，进程间就可能会因竞争不可抢占资源而导致死锁，并且死锁的发生总是在进程提出资源请求时.</li>\n<li>进程推进顺序不当：推进顺序不当，将会使两个或两个以上的进程出现这种情况：既占有部分资源又要申请其他阻塞进程所占有不可抢占资源的情况，从而导致这几个陷入死锁.</li>\n</ol>\n</li>\n<li>\n<p>产生死锁的 4 个必要条件:</p>\n<ol>\n<li>互斥条件：进程对所获得的资源进行排他性使用，任一时刻一个资源仅能被一个进程占用</li>\n<li>请求和保持条件：一个进程请求资源而得不到满足而阻塞自己时，并不释放已分配给他的资源，该条件也称为部分分配条件.</li>\n<li>不可抢占 (不剥夺) 条件：进程所获得的资源在未使用完毕之前不能被其他进程抢占，而只能由占用该资源的进程自己释放.</li>\n<li>循环条件：若干进程 (两个或两个以上) 形成一个循环等待链，链中每个进程都在等待该链中下一个进程所占用的资源.</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"第四章-存储管理\"><a class=\"markdownIt-Anchor\" href=\"#第四章-存储管理\">#</a> 第四章 存储管理</h2>\n<h3 id=\"考点-4\"><a class=\"markdownIt-Anchor\" href=\"#考点-4\">#</a> 考点</h3>\n<h4 id=\"1-逻辑地址和物理地址\"><a class=\"markdownIt-Anchor\" href=\"#1-逻辑地址和物理地址\">#</a> 1. 逻辑地址和物理地址</h4>\n<ol>\n<li>逻辑地址：逻辑地址由两个 16 位地址分量组成，<strong>段地址和偏移量</strong>，一般会这样表示–&gt; 段地址：偏移量。是应用程序角度看到的内存单元地址。 不同于物理地址（physical address），通过地址翻译器（address translator）或映射函数可以把逻辑地址转化为物理地址。(网上找的解释)</li>\n<li>物理地址：物理地址是实际存储在内存中的地址，在物理上表示内存单元的位置。(也被称为绝对地址或内存地址)</li>\n</ol>\n<h4 id=\"2-地址重定位\"><a class=\"markdownIt-Anchor\" href=\"#2-地址重定位\">#</a> 2. 地址重定位</h4>\n<ol>\n<li>\n<p>静态重定位 (要求空间是连续的)</p>\n<p>指在程序编译前，将程序中的逻辑地址映射到物理地址的过程。由于重定位操作在编译前完成，并且在程序运行中不再改变所以叫静态重定位.</p>\n<p>转换公式：绝对地址 (物理地址) = 相对地址 (逻辑地址) + 程序存放的内存起始地址</p>\n</li>\n<li>\n<p>动态重定位 (动态地址转换)</p>\n<p>指在程序执行过程中，动态地将逻辑地址映射到物理地址的过程，即当执行的指令设计访存地址 (此时为逻辑地址) 时在进行地址转换，由于重定位操作在程序运行时完成，所以叫动态重定位.</p>\n</li>\n</ol>\n<h4 id=\"3-可变分区存储管理\"><a class=\"markdownIt-Anchor\" href=\"#3-可变分区存储管理\">#</a> 3. 可变分区存储管理</h4>\n<ol>\n<li>\n<p>内部碎片 (可能考)</p>\n<p>一个分区内部浪费的空间称为内部碎片</p>\n</li>\n<li>\n<p>可变分区 (又称动态分区)</p>\n<p>可变分区是指内存分配过程中，可以根据系统的需要，动态地调整内存分配空间的大小。它可以避免因内存静态分配不合理导致的浪费空间。可变分区可以根据系统的需求，分配一些新的内存空间给进程，也可以回收一些空闲内存空间，使得内存利用率更高。有利于多道程序设计并进一步提高内存资源的利用率</p>\n</li>\n</ol>\n<h4 id=\"4-分页存储管理\"><a class=\"markdownIt-Anchor\" href=\"#4-分页存储管理\">#</a> 4. 分页存储管理</h4>\n<ol>\n<li>\n<p>分页存储管理的实现原理</p>\n<p>分页存储管理是一种内存管理技术，它将整个进程的地址空间划分为固定大小的页面，每个页面通常是 4KB 到 8KB。当一个进程需要访问一个地址时，操作系统首先检查地址是否在内存中，如果不是，则需要将页面调入内存。该过程在虚拟内存环境下实现，需要使用页表维护页面的映射关系。在内存不足时，操作系统还可以将未使用的页面调出内存，存储到硬盘上，这一过程称为页面置换。</p>\n<p>在为程序分配内存时，允许已页为单位将程序的各个页分别装入内存中相邻或不相邻的物理块中。由于程序的最后一页往往不能装满分配给他的物理块，于是会有一定程度的内存空间浪费，这部分被浪费的内存空间称为页内碎片</p>\n<p><strong>程序中的逻辑地址被转换为页号和业页内地址，转换公式:</strong></p>\n<p><strong>页内地址 = 逻辑地址 / 页长 (块长)</strong></p>\n<p><strong>页号 = 逻辑地址 % 块长</strong></p>\n<p><mark>注：页长即一页的大小</mark></p>\n</li>\n</ol>\n<h4 id=\"5-第四章地址转换例题必考\"><a class=\"markdownIt-Anchor\" href=\"#5-第四章地址转换例题必考\">#</a> 5. 第四章地址转换例题 (必考)</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201145005626.png?token=AQ6CS6KZHLF7UIN35FOPWILD3IF54\" alt=\"image-20230201145005626\"></p>\n<h4 id=\"6-虚拟存储管理非常重要必考\"><a class=\"markdownIt-Anchor\" href=\"#6-虚拟存储管理非常重要必考\">#</a> 6. 虚拟存储管理 (非常重要，必考)</h4>\n<ol>\n<li>\n<p>虚拟存储器的概念 (定义)</p>\n<p>虚拟存储器是指内存采取离散方式分配，自动实现进程在内外存之间的部分装入和部分对换，仅将进程的一部分程序和数据装入内存即可运行。从逻辑上上讲，是对内存容量进行扩充的一种虚拟的存储器系统。虚拟存储器的逻辑容量由内存和外存容量之和绝对，其运行速度接近于内存速度，而存储信息的成本接近于外存.</p>\n</li>\n</ol>\n<h4 id=\"7-页置换算法必考\"><a class=\"markdownIt-Anchor\" href=\"#7-页置换算法必考\">#</a> 7. 页置换算法 (必考)</h4>\n<ol>\n<li>\n<p>最佳置换算法 (复习课上老师说不考，但保险起见还是看看)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151121218.png?token=AQ6CS6PD7DDKOHKC2724F4LD3IINQ\" alt=\"image-20230201151121218\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151231007.png?token=AQ6CS6K7PHWQQNNZR2ADZUDD3IIR4\" alt=\"image-20230201151231007\"></p>\n</li>\n<li>\n<p>先进先出算法</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151530491.png?token=AQ6CS6LCSEAIMO7UNZYUXNTD3II5K\" alt=\"image-20230201151530491\"></p>\n</li>\n<li>\n<p>最近最久未使用算法</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151158225.png?token=AQ6CS6NUBNY7YVU3RBB465DD3IIP2\" alt=\"image-20230201151158225\"></p>\n</li>\n<li>\n<p>例题 (可能考)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151843534.png?token=AQ6CS6OTH4VX2HF37UCWEZ3D3IJJE\" alt=\"image-20230201151843534\"></p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201151903144.png?token=AQ6CS6PEOJVE3HN3URNWRYLD3IJKM\" alt=\"image-20230201151903144\"></p>\n</li>\n</ol>\n<h2 id=\"第五章-设备管理\"><a class=\"markdownIt-Anchor\" href=\"#第五章-设备管理\">#</a> 第五章 设备管理</h2>\n<h3 id=\"考点-5\"><a class=\"markdownIt-Anchor\" href=\"#考点-5\">#</a> 考点</h3>\n<h4 id=\"1-设备的分类会考\"><a class=\"markdownIt-Anchor\" href=\"#1-设备的分类会考\">#</a> 1. 设备的分类 (会考)</h4>\n<ol>\n<li>按使用特性分类 (可分为两类):\n<ul>\n<li>存储设备：又称为外存或辅助存储器，用于永久保存用户使用计算机处理的信息。磁盘，磁带，光盘和 U 盘都属于存储设备。一般来说存储设备既是输入设备又是输出设备.</li>\n<li>I/O 设备：用户通过直接操作 I/O 设备与计算机通信。输入设备是计算机用来接受外部信息的设备，如键盘，扫描仪等，输出设备则将计算机加工处理的信息送向外部，如显示器，打印机等.</li>\n</ul>\n</li>\n<li>按信息传输速率分类 (分三类)\n<ul>\n<li>低速设备：指传输速率为每秒几字节至几百字节的设备，如键盘，鼠标等.</li>\n<li>中速设备：指传输速率为每秒几千字节至几万字节的设备，如各种打印机.</li>\n<li>高速设备：指传输速率为每秒几十万字节甚至几兆字节的设备，如闪存 (优盘), 光盘机，磁盘机及磁带机等.</li>\n</ul>\n</li>\n<li>按信息传输单位分类 (两类)\n<ul>\n<li>字符设备：这类设备用于数据的输入和输出，基本单位是字符，古称为字符设备，如打印机，键盘，显示终端等。字符设备的每个传输单位是字符，字符是不可寻址的</li>\n<li>块设备：这类设备的信息存取总已数据块为单位。块设备属于要有结构设备，典型的块设备是磁盘.</li>\n</ul>\n</li>\n<li>按资源分配方式分类 (三类)\n<ul>\n<li>独占设备：指在一段时间内只允许一个用户 (进程) 访问的设备，独占设备属于临界资源，并发执行的各进程必须已互斥方式使用独占设备，进程一旦获得这类设备，就有该进程独占至使用完释放，大多数低字符设备如终端，打印机，扫描仪就属于独占设备</li>\n<li>共享设备：指在一段时间内允许多个用户 (进程) 同时访问的设备，共享设备由于在宏观上允许多个进程同时访问，因此设备利用率高，但是这类设备在任一时刻仍然只允许一个进程访问，即微观上各进程的访问只能交替进行，磁盘就是共享设备的典型代表.</li>\n<li>虚拟设备：指通过虚拟计算 (如 SPOOLing 技术), 将一台独占设备造成若干台逻辑上共享的设备，提供给多个用户 (进程) 同时使用，以提高设备利用率。局域网中提供给多个用户共享的打印机就是使用虚拟设备的例子.</li>\n</ul>\n</li>\n<li>按设备的从属关系分类 (两类，简单来说系统设备就是安装系统就有自动有驱动的设备，键盘鼠标等，用户设备就是需要你提供驱动的设备)\n<ul>\n<li>系统设备：操作系统生成时就纳入系统管理范围的设备，通常也称为标准设备。如键盘，显示器，磁盘驱动等.</li>\n<li>用户设备：用户在完成任务过程中特性需要的设备，由于这些设备是操作系统生成时未经登记的非标准设备，因此对用户来说，需要向系统提供使用该设备的有关程序 (如设备驱动程序等), 而对系统来说，则需要提供接纳这些设备的方法，以便将它们纳入系统的管理中.</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-具有通道的io系统结构图\"><a class=\"markdownIt-Anchor\" href=\"#2-具有通道的io系统结构图\">#</a> 2. 具有通道的 I/O 系统结构图</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201155904502.png?token=AQ6CS6OMKRTX5CRZ7OTMFMTD3IOAQ\" alt=\"image-20230201155904502\"></p>\n<h4 id=\"3-io设备控制方式四种\"><a class=\"markdownIt-Anchor\" href=\"#3-io设备控制方式四种\">#</a> 3. I/O 设备控制方式 (四种)</h4>\n<ol>\n<li>\n<p><strong>程序直接 I/O 控制方式</strong></p>\n<p>早期计算机系统中没有中断系统，CPU 对 I/O 设备的控制只能由程序直接控制，但由于传输数据时 CPU 的速度明显快于 I/O 设备，于是 CPU 需要不断测试 I/O 设备，只有当设备空闲时才能进行数据传送，这种控制方式称为程序直接 I/O 控制方式，又称为查询方式或忙 - 等待方式。</p>\n</li>\n<li>\n<p><strong>程序中断 I/O 控制方式</strong></p>\n<p>程序中断 I/O 控制方式也称中断处理方式。由于循环测试 I/O 方式中的外设是被动控制对象，因此 CPU 需要对其进行连续监控。计算机系统引入中断技术后技可以增加 I/O 设备的主动性，即每当设备完成 I/O 操作时就以中断请求方式生动向 CPU 汇报，同时 CPU 内部也增加了检测中断和白动响应中断的功能，手是产生了新的 I/O 控制方式，即中断 I/O 控制方式。CPU 在启动 I/O 设备之后可以转去执行其他程序，仅在收到 I/O 中断请求时再花费极少时间来处理该中断。</p>\n</li>\n<li>\n<p><strong>直接存储器存取 I/O 控制方式</strong></p>\n<ul>\n<li>\n<p><strong>DMA 控制方式</strong> (可能会考)</p>\n<p>目前在块设备的 I/O 系统中，普遍采用直接存储器存取 (Direct Memory Acees,DMA）I/O 控制方式，即 DMA 控制方式。在该方式中，外部设备在 DMA 控制器支持下绕过 CPU 直接与内存交换数据，每次交换可以传送一个数据块，在每个数据块的传送期间无须 CPU 的干预。DMA 控制方式下的地址总线和数据总线以及一些控制信号线都是与 CPU 共用的。平时这些总线和控制信号线由 CPU 管理使用，当采用 DMA 进行直接内存数据交换时，DMA 采取挪用 CPU 工作周期和 DMA 控制器总线控制权的方法，由 DMA 控制器接管 CPU 所管理的总线，然后由 DMA 控制器控制外部设备与内存之间的成批数传送，在所有数据传送完成后由 CPU 回收总线控制权。即 DMA 控制方式进一步减少了 CPU 对 I/O 过程的干预，从每传输一个字 (字节) 干预一次减少到没传输一个数据块干预一次，因此这是一种效率很高的传输方式.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>I/O 通道控制方式</strong></p>\n<p>I/O 通道控制方式与 DNA 控制方式类似，也是以内存为中心实现数据在设备与内存的直接交换。在 I/O 通道控制方式下，当进程发出 I/O 请求后，只需给 CPU 指出通道相应的操作和使用的 I/O 设备，即可执行启动通道的指令来启动通道，并从内存中调出相应的通道程序予以执行。此时 CPU 将该 I/O 请求任务交由通道控制完成，当整个 I/O 任务在通道控制下完成之后，再由通道发出中断请求信号，此时 CPU 响应中断并进行后续处理。因此 I/O 通道进一步减少了 CPU 对 I/O 过程的干预，既减轻了 CPU 的工作负担，也提升了计算机系统的并行工作能力，使现代计算机系统的功能更加完善。正是有了中断技术和通道技术，才真正实现了 CPU 与 I/O 设备的并行工作，由此也真正实现了多道程序设计</p>\n</li>\n</ol>\n<h4 id=\"4-缓冲技术\"><a class=\"markdownIt-Anchor\" href=\"#4-缓冲技术\">#</a> 4. 缓冲技术</h4>\n<ol>\n<li>缓冲技术 (位于内存里面)—&gt; 考选择题</li>\n</ol>\n<h4 id=\"5-虚拟设备技术\"><a class=\"markdownIt-Anchor\" href=\"#5-虚拟设备技术\">#</a> 5. 虚拟设备技术</h4>\n<ol>\n<li>\n<p>SPOOLing 技术</p>\n<p>SPOOLing 技术又称假脱机技术，他是在联机的情况下实现脱机 I/O 功能的，即用一道程序模拟外围输入控制机，将用户进程需要的数据从慢速设备预先输入到磁盘上，当用户进程需要数据时再从磁盘上直接读出，同时用另一道程序模拟外围输出控制机，用户进程将输出的数据先传输到磁盘上，然后再由程序模拟的外围输入机将暂存在磁盘上的数据在慢速设备上逐个字符地输出.</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201164740153.png?token=AQ6CS6MGPLDBGKT4SNRZYF3D3ITWW\" alt=\"image-20230201164740153\"></p>\n<p><strong>SPOOLing 系统</strong>具有以下三方面的<strong>特点</strong>:</p>\n<ul>\n<li>** 提高了 I/O 的速度.** 从对低速 I/O 设备进行的 I/O 操作变为输入井或输出井 (磁盘上) 的操作。如同脱机操作一样提高了 I/O 速度，缓和了 CPU 与低速 I/O 设备速度不匹配的矛盾.</li>\n<li><strong>将独占设备改造成了共享设备</strong></li>\n<li><strong>实现了虚拟设备功能.</strong> 多个进程同时使用一个独占设备，对每一进程而言都认为自己独占了这一设备，不过该设备知识逻辑上的设备 (虚拟设备)</li>\n</ul>\n</li>\n</ol>\n<p>​</p>\n<h4 id=\"6-设备的分配方式两种分配方式\"><a class=\"markdownIt-Anchor\" href=\"#6-设备的分配方式两种分配方式\">#</a> 6. 设备的分配方式 (两种分配方式)</h4>\n<ol>\n<li>\n<p>设备的静态分配</p>\n<p>指在用户进程开始执行前，操作系统就将该系统所需要的全部设备，设备控制器和通道一次性的分配给他。进程运行后，这些设备，设备控制器和通道一直被该进程所占用，直至该进程运行结束或被撤销</p>\n<p>静态分配方式破坏了死锁的 &quot;请求和保持条件&quot;, 因此不会导致系统发生死锁，但是设备利用率低，一些进程可能长时间得不到运行</p>\n</li>\n<li>\n<p>设备的动态分配</p>\n<p>指进程在运行过程中需要 I/O 时再由操作系统为其分配设备。即进程运行过程中若需要使用设备则向系统提出申请，操作系统根据收到的设备申请按实现制定的分配策略为申请进程分配设备，设备控制器和通道，进程用完后就立即释放</p>\n<p>动态分配有利于提高设备利用率，但是分配不当可 - 能导致系统死锁</p>\n</li>\n</ol>\n<h4 id=\"7-磁盘调度会考\"><a class=\"markdownIt-Anchor\" href=\"#7-磁盘调度会考\">#</a> 7. 磁盘调度 (会考)</h4>\n<ol>\n<li>\n<p>影响磁盘访问时间的三个因素</p>\n<ul>\n<li>\n<p>寻道时间</p>\n<p>把读写磁头移动到所需要访问 (读写) 的磁道位置所需要的平均时间</p>\n</li>\n<li>\n<p>旋转延迟时间</p>\n<p>在磁头到达所要访问的磁道位置后，等待所要访问的扇区旋转到磁头下方的平均时间.</p>\n<p>平均来讲，磁道上所要访问的扇区旋转到磁头下约半圈距离，因此旋转延迟通常为旋转一圈时间的一半，即</p>\n<p>平均访问时间 = 寻道时间 + 旋转延迟时间</p>\n</li>\n<li>\n<p>数据传输时间</p>\n<p>指实际读写磁盘数据的时间</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"8-磁盘调度算法必考重点\"><a class=\"markdownIt-Anchor\" href=\"#8-磁盘调度算法必考重点\">#</a> 8. 磁盘调度算法 (必考，重点)</h4>\n<ol>\n<li>\n<p>先来先服务调度算法 (重点)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201215052970.png?token=AQ6CS6K2CZOEWBAMCC3ZNUTD3JXIG\" alt=\"image-20230201215052970\"></p>\n</li>\n<li>\n<p>最短寻道时间优先算法 (重点)</p>\n<p><img data-src=\"https://raw.githubusercontent.com/cao-jvm/picbed/master/image-20230201214955489.png?token=AQ6CS6PQV6RHUYQUNNF4JV3D3JXEK\" alt=\"image-20230201214955489\"></p>\n</li>\n<li>\n<p>扫描算法 (熟悉即可)</p>\n</li>\n<li>\n<p>电梯算法 (熟悉即可)</p>\n</li>\n<li>\n<p>循环扫描算法 (熟悉即可)</p>\n</li>\n</ol>\n<h2 id=\"第六章-文件管理\"><a class=\"markdownIt-Anchor\" href=\"#第六章-文件管理\">#</a> 第六章 文件管理</h2>\n<h3 id=\"考点-6\"><a class=\"markdownIt-Anchor\" href=\"#考点-6\">#</a> 考点</h3>\n<h2 id=\"七-习题考试题目都是从里面选\"><a class=\"markdownIt-Anchor\" href=\"#七-习题考试题目都是从里面选\">#</a> 七 习题（考试题目都是从里面选）</h2>\n<h3 id=\"注意判断题要改正错误的地方比如能干什么错了要改成不能\"><a class=\"markdownIt-Anchor\" href=\"#注意判断题要改正错误的地方比如能干什么错了要改成不能\">#</a> 注意：判断题要改正错误的地方，比如能干什么错了，要改成不能</h3>\n<h3 id=\"第一章作业\"><a class=\"markdownIt-Anchor\" href=\"#第一章作业\">#</a> 第一章作业</h3>\n<h3 id=\"一-单选题\"><a class=\"markdownIt-Anchor\" href=\"#一-单选题\">#</a> 一、单选题</h3>\n<p>1. 操作系统在计算机系统中位于（ ）之间。（4.0 分）</p>\n<p>A、CPU 和用户<br>\n B、CPU 和内存<br>\n C、计算机硬件和用户<br>\n D、计算机硬件和软件<br>\n正确答案: C<br>\n2. 下列选项中，（  ）不是操作系统关心的主要问题。（4.0 分）</p>\n<p>A、管理计算机裸机<br>\n B、设计、提供用户程序与计算机硬件系统的界面<br>\n C、管理计算机系统资源<br>\n D、高级程序设计语言的编译程序<br>\n正确答案: D<br>\n3. 操作系统的逻辑结构不包含（ ）。</p>\n<p>（4.0 分）</p>\n<p>A、混合型结构<br>\n B、单内核结构<br>\n C、分层式结构<br>\n D、微内核结构<br>\n正确答案: A<br>\n4. 操作系统的三种基本类型是（ ）。（4.0 分）</p>\n<p>A、批处理系统、分时操作系统和网络操作系统<br>\n B、分时操作系统、实时操作系统和分布式操作系统<br>\n C、批处理系统、分时操作系统和实时操作系统<br>\n D、批处理系统、分时操作系统和微机操作系统<br>\n正确答案: C<br>\n5. 现在操作系统的基本特征是（ ）、资源的共享和操作的异步性。（4.0 分）</p>\n<p>A、多道程序设计<br>\n B、中断处理<br>\n C、程序的并发执行<br>\n D、实现分时与实时处理<br>\n正确答案: C<br>\n6.（ ）不是分时操作系统的基本特征。（4.0 分）</p>\n<p>A、同时性<br>\n B、独立性<br>\n C、实时性<br>\n D、交互性<br>\n正确答案: C<br>\n7. 在设计实时操作系统时，（ ）不是重点考虑的问题。（4.0 分）</p>\n<p>A、及时响应、快速处理<br>\n B、高安全性<br>\n C、高可靠性<br>\n D、提高系统资源的利用率<br>\n正确答案: D<br>\n8.（ ）操作系统允许在一台主机上同时连接多台终端，多个用户可以通过各自的终端同时交互地使用计算机（4.0 分）</p>\n<p>A、网络<br>\n B、分布式<br>\n C、分时<br>\n D、实时<br>\n正确答案: C<br>\n9. 多道程序设计技术是指（ ）。（4.0 分）</p>\n<p>A、在实时系统中并发运行多个程序<br>\n B、在分布式系统中同一时刻运行多个程序<br>\n C、在一个 CPU 上同一时刻运行多个程序<br>\n D、在一个 CPU 上并发运行多个程序<br>\n正确答案: D<br>\n10.<br>\nCPU 执行的指令被分为两类：其中一类称为特权指令，只允许（ ）使用。（4.0 分）</p>\n<p>A、操作员<br>\n B、联机用户<br>\n C、操作系统<br>\n D、用户程序<br>\n正确答案: C<br>\n11. 中断的概念是指（ ）。（4.0 分）</p>\n<p>A、暂停 CPU 执行<br>\n B、暂停 CPU 对当前运行程序的执行<br>\n C、停止整个系统的运行<br>\n D、使 CPU 空转<br>\n正确答案: B<br>\n12. 用户程序在用户态下使用系统调用引起的中断属于（ ）（4.0 分）</p>\n<p>A、硬件故障中断<br>\n B、程序中断<br>\n C、访管中断<br>\n D、外部中断<br>\n正确答案: C<br>\n13. 系统调用是（ ）（4.0 分）</p>\n<p>A、用户编写的一个子程序<br>\n B、高级语言中的库程序<br>\n C、系统系统中的一条命令<br>\n D、操作系统向用户程序提供的接口</p>\n<p>正确答案: D<br>\n14. 操作系统完成用户请求的系统调用功能后，应使 CPU（ ）工作。（4.0 分）</p>\n<p>A、维持在用户态<br>\n B、从用户态转到内核态<br>\n C、维持在内核态<br>\n D、从内核态转换到用户态<br>\n正确答案: D<br>\n15. 中断系统一般是由相应的（ ）组成的。（4.0 分）</p>\n<p>A、硬件<br>\n B、软件<br>\n C、硬件和软件</p>\n<p>D、以上都不是<br>\n正确答案: C<br>\n 二、判断题<br>\n 16. 采用多道程序设计的系统中，系统中的程序道数越多，系统的效率越高。（4.0 分）</p>\n<p>正确答案:×<br>\n 多道程序设计是一种操作系统结构，其主要目的是让多个程序同时运行，从而提高系统的资源利用率，提高并发性。但是，程序道数越多，系统中的调度和管理开销就会增加，对系统的性能造成影响。因此，程序道数多少与系统效率的高低不一定成正比关系。<br>\n17. 应用软件是加在裸机上的第一层软件。（4.0 分）</p>\n<p>正确答案:×<br>\n 操作系统通常是第一层软件，它在裸机上运行并为应用软件提供了基础服务<br>\n 18. 多道程序设计可以缩短系统中程序的执行时间。（4.0 分）</p>\n<p>正确答案:×<br>\n 多道程序设计的主要目的是提高系统的并行处理能力，而不一定能缩短程序的执行时间。多道程序设计可以让多个任务并行运行，但具体对程序执行时间的影响取决于任务之间的相互关系、资源限制以及硬件配置等多个因素<br>\n 19. 操作系统的所有程序都必须常驻内存。（4.0 分）</p>\n<p>正确答案:×<br>\n 不是所有操作系统程序都必须常驻内存，一些程序可能在需要时加载到内存中。<br>\n20. 微内核结构的操作系统具有较高的灵活性和扩展性。（4.0 分）</p>\n<p>正确答案:√<br>\n21. 通常将 CPU 模式分为内核态和用户态，这样做的目的是为了提高运行速度。（4.0 分）</p>\n<p>正确答案:×<br>\n 通常将 CPU 模式分为内核态和用户态，主要是为了保证系统安全，防止用户程序干扰系统程序和数据，并不是为了提高运行速度。<br>\n22. 从响应的角度看，分时系统和实时系统的要求类似。（4.0 分）</p>\n<p>正确答案:×<br>\n 分时系统和实时系统对响应的要求是不同的，分时系统允许不确定的响应时间，而实时系统要求精确的响应时间。<br>\n23. 使计算机系统能够被方便使用和高效地工作是操作系统的两个主要设计目标。（4.0 分）</p>\n<p>正确答案:√<br>\n24. 用户程序有时也可以在内核态下运行。（4.0 分）</p>\n<p>正确答案:×<br>\n 通常，用户程序只能在用户态下运行，以保护系统免受用户程序的损害。<br>\n25. 执行系统调用时会产生中断。（4.0 分）</p>\n<p>正确答案:√</p>\n<h3 id=\"第二章作业\"><a class=\"markdownIt-Anchor\" href=\"#第二章作业\">#</a> 第二章作业</h3>\n<p>一、单选题<br>\n 1. 以下对进程的描述中，错误的是（ ）（4.0 分）</p>\n<p>A、进程是动态的概念<br>\n B、进程执行需要 CPU<br>\nC、进程是有生命期的<br>\n D、进程是指令的集合<br>\n正确答案: D<br>\n2. 进程最基本的特征是 ( )（4.0 分）</p>\n<p>A、动态性和并发性<br>\n B、顺序性和可再现性<br>\n C、不可再现性<br>\n D、执行过程的封闭性<br>\n正确答案: A<br>\n3. 一个进程是（ ）（4.0 分）</p>\n<p>A、由 CPU 执行的一个程序<br>\n B、一个独立的程序 + 数据集<br>\n C、PCB 结构、程序和数据的组合<br>\n D、一个独立的程序<br>\n正确答案: C<br>\n4. 在多道程序环境下，操作系统分配资源以（ ）为基本单位（4.0 分）</p>\n<p>A、程序<br>\n B、指令<br>\n C、进程<br>\n D、作业<br>\n正确答案: C<br>\n5. 当（ ）时，进程从运行状态转变为就绪状态（4.0 分）</p>\n<p>A、进程被调度程序选中</p>\n<p>B、时间片到<br>\n C、等待某一事件<br>\n D、等待的事件结束<br>\n正确答案: B<br>\n6. 一个进程被唤醒意味着（ ）（4.0 分）</p>\n<p>A、该进程一定重新占用 CPU<br>\nB、它的优先级变为最大<br>\n C、其 PCB 移至进程就绪队列的队首<br>\n D、进程变为就绪状态<br>\n正确答案: D<br>\n7.（ ）必会引起进程的切换（4.0 分）</p>\n<p>A、一个进程创建后进入进程就绪队列<br>\n B、一个进程从运行状态变为就绪状态</p>\n<p>C、一个进程从阻塞状态变为就绪状态<br>\n D、以上都不对<br>\n正确答案: B<br>\n8. 进程调度主要负责（ ）（4.0 分）</p>\n<p>A、选一个作业进入内存<br>\n B、选一个进程占用 CPU<br>\nC、建立一个新进程<br>\n D、撤消一个进程<br>\n正确答案: B<br>\n9. 下面的叙述中，（ ）不是创建进程所必需的（4.0 分）</p>\n<p>A、由进程调度程序为进程分配 CPU<br>\nB、建立一个 PCB<br>\nC、为进程分配内存<br>\n D、将 PCB 链入进程就绪队列<br>\n正确答案: A<br>\n10. 当一个进程运行时，系统可基于某种原则强行将其撤下并把 CPU 分配给其他进程，这种调度方式是（ ）（4.0 分）</p>\n<p>A、非抢占方式<br>\n B、抢占方式<br>\n C、中断方式<br>\n D、查找方式<br>\n正确答案: B<br>\n11. 作业的周转时间是（ ）（4.0 分）</p>\n<p>A、作业等待时间<br>\n B、作业执行时间<br>\n C、作业等待时间 + 作业执行时间<br>\n D、以上都不对<br>\n正确答案: C<br>\n12. 现在三个同时到达的作业 J1、J2 和 J3，它们的执行时间分别为 T1、T2 和 T3，且 T1&lt;T2&lt;T3，系统按单道方式运行且采用短作业优先算法，则平均周转时间是（ ）（4.0 分）</p>\n<p>A、T1+T2+T3<br>\nB、（3T1+2T2+T3）/3<br>\nC、（T1+T2+T3）/3<br>\nD、（T1+2T2+3T3）/3<br>\n 正确答案: B<br>\n13. 一个作业 8：00 到达系统，估计运行时间为 1 小时，若从 10：00 开始执行该作业，则其响应比是（ ）（4.0 分）</p>\n<p>A、2<br>\nB、1<br>\nC、3<br>\nD、0.5<br>\n 正确答案: C<br>\n14. 有 3 个作业 J1、J2 和 J3，其运行时间分别是 2、5 和 3 小时，假定它们同时到达并在同一台 CPU 上以单道方式运行，则平均周转时间最小的执行序列是（ ）（4.0 分）</p>\n<p>A、J1、J2、J3<br>\nB、J3、J2、J1<br>\nC、J2、J1、J3<br>\nD、J1、J3、J2<br>\n 正确答案: D<br>\n15. 为了优先照顾紧急或重要的进程，应采用（ ）调度算法（4.0 分）</p>\n<p>A、先来先服务<br>\n B、时间片轮转<br>\n C、优先级<br>\n D、高响应比优先<br>\n正确答案: C<br>\n 二、判断题<br>\n 16. 不同的进程必然对应不同的程序（4.0 分）</p>\n<p>正确答案:×<br>\n17. 并发是并行的不同表述，其原理相同（4.0 分）</p>\n<p>正确答案:×<br>\n18. 进程控制块是用户进程的私有数据结构，每个进程仅有一个 PCB。（4.0 分）</p>\n<p>正确答案:×<br>\n19. 当一个进程从阻塞态变为就绪态时，一定有一个进程从就绪态变为运行态。（4.0 分）</p>\n<p>正确答案:×<br>\n20. 当条件满足时，进程可以由阻塞态直接转换为运行态。（4.0 分）</p>\n<p>正确答案:×<br>\n21. 进程自身可以决定从运行态转换为阻塞态。（4.0 分）</p>\n<p>正确答案:√<br>\n22. 在抢占式进程调度下，现运行进程的优先级不低于系统中所有进程的优先级。（4.0 分）</p>\n<p>正确答案:×<br>\n23. 时间片的大小对轮转法的性能有很大影响，时间片太短会导致系统开销增加。（4.0 分）</p>\n<p>正确答案:√<br>\n24. 在单 CPU 上的进程就绪队列和进程阻塞队列都只能有一个。（4.0 分）</p>\n<p>正确答案:×<br>\n25. 某进程被唤醒后立即投入运行，因此此系统采用的一定是抢占式进程调度。（4.0 分）</p>\n<p>正确答案:×</p>\n<h3 id=\"第三章作业\"><a class=\"markdownIt-Anchor\" href=\"#第三章作业\">#</a> 第三章作业</h3>\n<p>一、单选题<br>\n 1. 两个并发进程之间（  ）。（5.0 分）</p>\n<p>A、一定存在互斥关系</p>\n<p>B、一定存在同步关系<br>\n C、彼此独立相互无关<br>\n D、可能存在同步或互斥关系<br>\n正确答案: D<br>\n2. 以下关于临界资源的叙述中，正确的是（ ）。（5.0 分）</p>\n<p>A、临界资源是共享资源<br>\n B、临界资源是任意共享资源<br>\n C、临界资源是互斥资源<br>\n D、临界资源是同时共享资源<br>\n正确答案: C<br>\n3. 一个正在访问临界资源的进程由于又申请 I/O 操作而被阻塞时，（ ）。（5.0 分）</p>\n<p>A、可以允许其他进程进入该进程的临界区<br>\n B、不允许其他进程进入临界区和占用 cpu 执行<br>\n C、可以允许其他就绪进程占用 cpu 执行<br>\n D、不可以允许其他进程占用 cpu 执行<br>\n正确答案: C<br>\n4. 设与某互斥资源相关联的信号量初值为 3，当前值为 1 时，若 m 表示该资源的可用个数，n 表示等待该资源的进程数，则 m,n 分别是（ ）。（5.0 分）</p>\n<p>A、0，1<br>\nB、1，0<br>\nC、1，2<br>\nD、2，0<br>\n 正确答案: B<br>\n5. 对两个并发进程，设互斥信号量为 mutex (mutex.value 的初值为 1)，若 mutex.value 的当前值为 - 1，则（ ）。（5.0 分）</p>\n<p>A、表示没有进程进入临界区<br>\n B、表示有一个进程进入临界区<br>\n C、表示有一个进程进入临界区，而另一个进程等待进入临界区<br>\n D、表示有两个进程进入临界区<br>\n正确答案: C<br>\n6. 若有一个进程因在互斥信号量 mutex 上执行 V (mutex) 操作而导致唤醒另一个阻塞进程，则执行 V (mutex) 之后 mutex.value 的值为（ ）。（5.0 分）</p>\n<p>A、大于 0<br>\nB、小于 0<br>\nC、大于等于 0<br>\nD、小于等于 0<br>\n 正确答案: D<br>\n7. 若系统中有 n 个进程，则进程就绪队列中进程的个数最多为（ )。（5.0 分）</p>\n<p>A、n+1<br>\nB、n<br>\nC、n-1<br>\nD、1<br>\n 正确答案: C<br>\n8. 若系统中有 n 个进程，则进程阻塞队列中进程的个数最多为（ )。（5.0 分）</p>\n<p>A、n+1<br>\nB、n<br>\nC、n-1<br>\nD、1<br>\n 正确答案: B<br>\n9. 在操作系统中，死锁出现是指（ ）。（5.0 分）</p>\n<p>A、计算机系统发生重大故障<br>\n B、资源个数远小于进程数<br>\n C、若干进程因竞争资源而无限等待其他进程释放已占有的资源</p>\n<p>D、进程同时申请的资源数超过资源总数<br>\n正确答案: C<br>\n10. 某系统中有 11 台打印机，n 个进程共享打印机资源，每个进程要求获得 3 台打印机，当 n 的取值不超过（ ）时，系统不会发生死锁。（5.0 分）</p>\n<p>A、4<br>\nB、5<br>\nC、6<br>\nD、7<br>\n 正确答案: B<br>\n 二、判断题<br>\n 11. 对临界资源应采用互斥访问方式来实现共享。（5.0 分）</p>\n<p>正确答案:√<br>\n12. 进程 A 与进程 B 共享变量 S1，需要互斥；进程 B 与进程 C 共享变量 S2，需要互斥，从而进程 A 与进程 C 也必须互斥。（5.0 分）</p>\n<p>正确答案:×<br>\n 进程 A 与进程 C 共享变量 S1 和 S2，需要互斥，但从进程 A 与进程 B 的互斥关系和进程 B 与进程 C 的互斥关系不能推出进程 A 与进程 C 必须互斥的结论。<br>\n13.P、V 操作只能实现进程互斥，不能实现进程同步。（5.0 分）</p>\n<p>正确答案:×<br>\nP、V 操作不仅可以实现进程互斥，还可以实现进程同步。P 操作（也称为测试并且减少操作）可以保证在对共享资源进行操作之前先测试该资源是否可用。V 操作（也称为增加操作）可以增加共享资源的数量，从而启动等待该资源的其他进程。因此，通过 P、V 操作，可以实现进程的互斥与同步。<br>\n14. 在信号量上除能执行 P、V 操作外，不能执行其他任何操作。<br>\n（5.0 分）</p>\n<p>正确答案:√<br>\n15. 仅当一个进程退出临界区以后，另一个进程才能进入相应的临界区。（5.0 分）</p>\n<p>正确答案:√<br>\n16. 若信号量的初值为 1，则用 P 操作可以禁止任何进程进入临界区。（5.0 分）</p>\n<p>正确答案:×<br>\n 若信号量的初值为 1，P 操作可以禁止一个进程进入临界区，但不能禁止全部进程进入临界区。在多进程的环境下，只有当信号量的值为 0 时，才能禁止其他进程进入临界区。<br>\n17. 由于死锁是一种与时间有关的错误，因此它与进程推进的速度无关。（5.0 分）</p>\n<p>正确答案:×<br>\n 死锁与进程推进的速度有关。死锁是由多个进程在请求与占有资源的不当使用导致的，当进程在请求某个资源时，如果该资源已经被其他进程占用且该进程不能等待，那么它会一直等待，这将导致死锁。如果死锁发生时进程推进速度较慢，那么死锁状态会持续很长时间，因此，死锁与进程推进的速度有关<br>\n 18. 当进程数大于资源数时，进程竞争资源必然产生死锁。（5.0 分）</p>\n<p>正确答案:×<br>\n 当进程数大于资源数时，有可能发生死锁，也有可能不发生死锁。死锁的发生与进程数与资源数的关系以及进程对资源的请求和释放有关，而不仅仅是进程数与资源数的关系。<br>\n19. 当有 m 个进程的操作系统出现死锁时，死锁进程的个数 k 为 1&lt;k&lt;=m。（5.0 分）</p>\n<p>正确答案:√<br>\n20. 银行家算法是预防死锁发生的方法。（5.0 分）</p>\n<p>正确答案:×<br>\n 是避免</p>\n<h3 id=\"第四章作业\"><a class=\"markdownIt-Anchor\" href=\"#第四章作业\">#</a> 第四章作业</h3>\n<p>一、单选题<br>\n 1. 静态重定位的时机是（  ）<br>\n（5.0 分）</p>\n<p>A、程序编译时<br>\n B、程序链接时<br>\n C、程序装入时<br>\n D、程序运行时<br>\n正确答案: C<br>\n2. 采用动态重定位方式装入程序，其地址转换工作是在当（  ）完成的（5.0 分）</p>\n<p>A、程序装入时<br>\n B、程序被选中时</p>\n<p>C、执行一条指令时<br>\n D、程序在内存中移动时<br>\n正确答案: C<br>\n3. 以下存储管理方式中，不适合多道程序设计系统的是（ ）（5.0 分）</p>\n<p>A、单一连续分配<br>\n B、固定分区分配<br>\n C、可变分区分配<br>\n D、分页存储管理<br>\n正确答案: A<br>\n4. 在固定分区分配中，每个分区的大小（  ）（5.0 分）</p>\n<p>A、相同<br>\n B、随程序长度变化<br>\n C、可以不同但预先固定<br>\n D、可以不同但根据程序长度固定<br>\n正确答案: C<br>\n5. 在可变分区存储管理中，采用拼接技术的目的是（  ）（5.0 分）</p>\n<p>A、合并空闲分区<br>\n B、合并分配区<br>\n C、增加内存容量<br>\n D、便于地址转换<br>\n正确答案: A<br>\n6.（ ）存储管理支持多道程序设计，算法简单但存储碎片多（5.0 分）</p>\n<p>A、分段<br>\n B、分页<br>\n C、固定分区<br>\n D、段页式<br>\n正确答案: C<br>\n7. 在分页存储管理系统中，程序的地址空间是连续的，分页是由（ ）完成的（5.0 分）</p>\n<p>A、程序员</p>\n<p>B、硬件<br>\n C、编译程序</p>\n<p>D、以上都不对<br>\n正确答案: B<br>\n8. 在下列有关请求分页管理的叙述中，正确的是（ ）（5.0 分）</p>\n<p>A、程序和数据在开始执行前一次性装入<br>\n B、产生缺页中断一定要淘汰一个页<br>\n C、一个被淘汰的页一定要写回外存<br>\n D、在页表中要有中断位、访问位、修改位及外存地址等信息<br>\n正确答案: D<br>\n9. 程序在执行中发生缺页中断，由系统将该页调入内存后应继续执行（ ）（5.0 分）</p>\n<p>A、被中断的前一条指令<br>\n B、被中断的指令<br>\n C、被中断的后一条指令<br>\n D、程序的第一条指令<br>\n正确答案: B<br>\n10.（ ）是请求分页存储管理和分页存储管理的主要区别（5.0 分）</p>\n<p>A、地址重定位<br>\n B、不必将程序全部装入内存<br>\n C、采用快表技术<br>\n D、不必将程序装入内存连续区域<br>\n正确答案: B<br>\n 二、判断题<br>\n 11.CPU 可以直接存取外存上的信息（5.0 分）</p>\n<p>正确答案:×<br>\nCPU 不能直接存取外存上的信息，需要通过存储系统进行读写操作<br>\n 12. 存储管理的主要目的是扩大内存空间（5.0 分）</p>\n<p>正确答案:×<br>\n 存储管理的主要目的是利用内存空间，提高计算机的运行效率<br>\n 13. 动态重定位技术使得程序可以在内存中移动（5.0 分）</p>\n<p>正确答案:√<br>\n14. 存储保护是通过软件实现的（5.0 分）</p>\n<p>正确答案:×<br>\n 存储保护是通过硬件实现的。它通过分配每一段存储区的访问权限来实现保护，保证不同的程序不能访问彼此的存储区。软件也可以进一步提供存储保护功能，但最终还是由硬件实现。<br>\n15. 采用动态重定位技术的系统，可执行程序可以不经过任何改动就直接装入内存（5.0 分）</p>\n<p>正确答案:√<br>\n16. 采用可变分区方式将程序装入内存后，程序的地址不一定是连续的（5.0 分）</p>\n<p>正确答案:×<br>\n17. 在分页存储管理中，用户应将自己的程序划分成若干相等的页（5.0 分）</p>\n<p>正确答案:×<br>\n 在分页存储管理中，用户不需要将程序划分为若干相等的页，系统会自动进行划分。<br>\n18. 在分页存储管理中，程序装入内存后其地址是连续的（5.0 分）</p>\n<p>正确答案:×<br>\n 在分页存储管理中，程序装入内存后其地址不一定是连续的<br>\n 19. 在虚拟存储系统中，用户地址空间的大小可以不受任何限制（5.0 分）</p>\n<p>正确答案:×<br>\n 在虚拟存储系统中，用户地址空间的大小仍受硬件的物理内存限制。虚拟内存可以让用户地址空间看起来比实际的物理内存更大，但用户地址空间仍有一个最大限制，即物理内存的大小。<br>\n20. 在请求分页存储管理系统中，页的大小根据程序长度可以动态地改变（5.0 分）</p>\n<p>正确答案:×<br>\n 在请求分页存储管理系统中，页的大小是固定的，不能动态改变。</p>\n<h3 id=\"第五章作业\"><a class=\"markdownIt-Anchor\" href=\"#第五章作业\">#</a> 第五章作业</h3>\n<p>一、单选题<br>\n 1.（ ）是 CPU 与 I/O 设备之间的接口，它接收 CPU 发来的命令并去控制 I/O 设备的工作，使 CPU 从繁忙的设备控制事务中解脱出来（5.0 分）</p>\n<p>A、中断装置<br>\n B、系统设备表<br>\n C、设备控制器<br>\n D、逻辑设备表<br>\n正确答案: C<br>\n2. 用户通常采用（ ）来使用 I/O 设备（5.0 分）</p>\n<p>A、物理设备名<br>\n B、逻辑设备名<br>\n C、虚拟设备名<br>\n D、设备出厂号<br>\n正确答案: B<br>\n3. 通道程序是（ )（5.0 分）</p>\n<p>A、由一系列机器指令组成<br>\n B、由一系列通道指令组成<br>\n C、可以由高级语言编写<br>\n D、就是通道控制器<br>\n正确答案: B<br>\n4. 数据传输完毕，通道对 CPU 的请求形式是（ ）（5.0 分）</p>\n<p>A、陷入<br>\n B、中断<br>\n C、通道命令<br>\n D、跳转指令<br>\n正确答案: B<br>\n5. 缓冲技术的缓冲池是在（ ）（5.0 分）</p>\n<p>A、ROM<br>\nB、寄存器<br>\n C、内存<br>\n D、外存<br>\n正确答案: C<br>\n6.SPOOLing 系统克服了（ ）利用率低的缺点<br>\n（5.0 分）</p>\n<p>A、CPU<br>\nB、内存空间<br>\n C、独占设备<br>\n D、共享设备<br>\n正确答案: C<br>\n7.<br>\n 通过硬件和软件的功能扩充，把原来独占的设备改造成能为若干用户共享的设备，这种设备称为（ ）（5.0 分）</p>\n<p>A、存储设备</p>\n<p>B、系统设备<br>\n C、用户设备<br>\n D、虚拟设备<br>\n正确答案: D<br>\n8. 下列算法中用于磁盘移臂调度的是（ )（5.0 分）</p>\n<p>A、时间片轮转法<br>\n B、LRU 算法<br>\n C、电梯算法<br>\n D、优先级高者优先算法<br>\n正确答案: C<br>\n 二、判断题<br>\n 9. 设备无关性是指设备驱动程序独立于具体使用的物理设备。<br>\n（5.0 分）</p>\n<p>正确答案:×<br>\n 驱动程序 --&gt; 应用程序<br>\n 10.SPOOLing 是脱机 I/O 系统。（5.0 分）</p>\n<p>正确答案:×<br>\n 脱机 --&gt; 假脱机<br>\n 11. 磁盘高速缓冲区是设在磁盘上的一块磁盘空间。（5.0 分）</p>\n<p>正确答案:×<br>\n 磁盘高速缓冲区通常是设在主存中的一块内存空间，用于存储与磁盘交换的数据<br>\n 12. 设备分配算法主要有先来先服务和响应时间快者优先两种。<br>\n（5.0 分）</p>\n<p>正确答案:×<br>\n 其中设备的分配算法主要有两种算法：<br>\n①先来先服务<br>\n②优先级高者优先<br>\n 13. 磁盘移臂调度的目标是使磁盘旋转的周数最小。<br>\n（5.0 分）</p>\n<p>正确答案:×<br>\n 移臂调度算法又叫磁盘调度算法，根本目的在于有效利用磁盘，保证磁盘的快速访问<br>\n 14. 通道又称 I/O 处理机，它实现内存和外设之间的信息传输，并与 CPU 并行工作。（5.0 分）</p>\n<p>正确答案:√<br>\n15.<br>\n 最短寻道时间优先算法的调度原则是要求磁头的移动距离最小，该算法有产生 “饥饿” 的可能。（5.0 分）</p>\n<p>正确答案:√<br>\n16.<br>\n 缓冲技术是借用外存储器的一部分区域作为缓冲区。（5.0 分）</p>\n<p>正确答案:×<br>\n 外存储器 --&gt; 内存<br>\n 17.I/O 设备管理程序的主要功能是管理内存、控制器和通道。（5.0 分）</p>\n<p>正确答案:×<br>\n18. 等待设备的进程队列有时不必以先来先服务的顺序排队。（6.0 分）</p>\n<p>正确答案:√</p>\n",
            "tags": [
                "复习"
            ]
        }
    ]
}